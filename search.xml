<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AbpVNext审计日志学习</title>
      <link href="/2025/02/10/abpvnext-shen-ji-ri-zhi-xue-xi/"/>
      <url>/2025/02/10/abpvnext-shen-ji-ri-zhi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Abp-VNext-日志分为4类日志"><a href="#Abp-VNext-日志分为4类日志" class="headerlink" title="Abp VNext 日志分为4类日志"></a>Abp VNext 日志分为4类日志</h2><p>审计日志、安全日志(登陆日志)、实体变更日志、系统日志</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="第一种写入ES"><a href="#第一种写入ES" class="headerlink" title="第一种写入ES"></a>第一种写入ES</h4><h5 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>DependsOn<span class="token punctuation">(</span>typeof<span class="token punctuation">(</span>AbpAuditLoggingElasticsearchModule<span class="token punctuation">))</span><span class="token punctuation">]</span>public class YouProjectModule <span class="token keyword">:</span> AbpModule<span class="token punctuation">{</span>    // other<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h5><ul><li>AbpAuditLoggingElasticsearchOptions.IndexPrefix      索引前缀, 默认 auditlogging</li></ul><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>与租户模块集成, 跨租户时将会切换索引</p><h5 id="appsettings-json"><a href="#appsettings-json" class="headerlink" title="appsettings.json"></a>appsettings.json</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">{</span>  <span class="token string">"AuditLogging"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"Elasticsearch"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>      <span class="token string">"IndexPrefix"</span><span class="token keyword">:</span> <span class="token string">"auditlogging"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第二种写入数据"><a href="#第二种写入数据" class="headerlink" title="第二种写入数据"></a>第二种写入数据</h4><h5 id="模块引用-1"><a href="#模块引用-1" class="headerlink" title="模块引用"></a>模块引用</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>DependsOn<span class="token punctuation">(</span>typeof<span class="token punctuation">(</span>AbpAuditLoggingEntityFrameworkCoreModule<span class="token punctuation">))</span><span class="token punctuation">]</span>public class YouProjectModule <span class="token keyword">:</span> AbpModule<span class="token punctuation">{</span>  // other<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="配置项-1"><a href="#配置项-1" class="headerlink" title="配置项"></a>配置项</h5><p>请遵循 Volo.Abp.AuditLogging、Volo.Abp.Identity模块中的配置  </p><h5 id="appsettings-json-1"><a href="#appsettings-json-1" class="headerlink" title="appsettings.json"></a>appsettings.json</h5><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">{</span>  <span class="token string">"ConnectionStrings"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"AbpIdentity"</span><span class="token keyword">:</span> <span class="token string">"Server=127.0.0.1;Database=Identity;User Id=root;Password=*"</span>,    <span class="token string">"AbpAuditLogging"</span><span class="token keyword">:</span> <span class="token string">"Server=127.0.0.1;Database=AuditLogging;User Id=root;Password=*"</span>,  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NetCoreDump分析</title>
      <link href="/2025/02/08/netcoredump-fen-xi/"/>
      <url>/2025/02/08/netcoredump-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  由于.NET CORE 程序部署在Liunx 随着时间推移 耗用的内存只增不减,内存消耗异常、记录一下如何分析，参考文章:<a href="https://www.cnblogs.com/LinryBaker/p/18662030" target="_blank" rel="noopener">https://www.cnblogs.com/LinryBaker/p/18662030</a></p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><pre class="line-numbers language-bash"><code class="language-bash">docker pull mcr.microsoft.com/dotnet/sdk:7.0.100 -- 7.0.100 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="docker-run-容器"><a href="#docker-run-容器" class="headerlink" title="docker run 容器"></a>docker run 容器</h4><p>dotnet-dump工具依赖dotnet的sdk，如果宿主机中安装了sdk可以直接在宿主机中分析；如果不想污染宿主机环境可以拉取一个sdk镜像mcr.microsoft.com/dotnet/sdk，创建一个临时环境用于分析</p><pre class="line-numbers language-bash"><code class="language-bash"> docker run  --security-opt seccomp<span class="token operator">=</span>unconfined --name DotNetSDKDunp --rm -it -v D:\NetCoreDump:/tmp/coredump mcr.microsoft.com/dotnet/sdk:7.0.100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入容器安装 dotnet-dump<br>转到挂载出来的文件里面：cd  /tmp/coredump,安装dotnet-dump 工具</p><pre class="line-numbers language-bash"><code class="language-bash"> dotnet tool <span class="token function">install</span> -g dotnet-dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解释:<br>name: 容器名称<br>v:挂载文件</p><h4 id="查看安装DotNet-SDK-版本"><a href="#查看安装DotNet-SDK-版本" class="headerlink" title="查看安装DotNet SDK 版本"></a>查看安装DotNet SDK 版本</h4><pre class="line-numbers language-bash"><code class="language-bash">dotnet --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="分析内存泄漏"><a href="#分析内存泄漏" class="headerlink" title="分析内存泄漏"></a>分析内存泄漏</h4><p>命令：<br>dotnet-dump analyze 【dump文件名称】<br>dumpheap -stat  找到堆上的对象信息（注：此命令第一次执行时会消耗很久时间，请泡一杯茶耐心等候，如果服务器会自动断开连接的，建议下载到一台不会断开连接的机器进行分析，因为这里可能在没有分析出来连接就断开了）<br>dumpheap -mt  <mt> 列出所有与<mt>结构对应的对象，一般我都会找string对象的mt，看看里面大size的string对象是有哪些<br>do  <address> 查看对象详细信息<br>gcroot -all <address> 一般我也是找string地址，看看对象引用<br>help  帮助</address></address></mt></mt></p><p>由于对象信息很多且没有按照大小排序所以把日志持久化到本地</p><pre class="line-numbers language-bash"><code class="language-bash">logopen C:\Users\liusong\Desktop\分析日志\dumpheap_stat.txtdumpheap -mt 7f0c1fbd1038logclose C:\Users\liusong\Desktop\分析日志\dumpheap_stat.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>do [adress]<br>结果出来了，可以看到有很多占内存一样大的字符串，此时需要用到第四个命令<br><img src="../../source/images/netcoredump/image-1.png" alt="alt text"></p><p>注：如果是比较小的string，红框部分就会显示该string的内容，但是这个太大了，无法显示</p><p>在所有命令中一个命令一个命令试过之后，<br>找到两个命令<br>dq <address><br>du <address><br>先执行dq <address>,会得到一群类似adress的东西<br><img src="../../source/images/netcoredump/image-2.png" alt="alt text"></address></address></address></p><p>再du <adress> 注：这里的address就用上面的结果（每个都试下，因为不是每一个都有你想要的结果）</adress></p><p>其中一个结果如下：<br><img src="../../source/images/netcoredump/image-3.png" alt="alt text"></p>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发</title>
      <link href="/2024/11/20/wei-xin-xiao-cheng-xu-kai-fa/"/>
      <url>/2024/11/20/wei-xin-xiao-cheng-xu-kai-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h3><p>小程序地址<br><a href="https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&amp;token=210526085" target="_blank" rel="noopener">https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&amp;token=210526085</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Abp VNext扩展登陆方式</title>
      <link href="/2024/11/18/abp-vnext-kuo-zhan-deng-lu-fang-shi/"/>
      <url>/2024/11/18/abp-vnext-kuo-zhan-deng-lu-fang-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="Abp-VNext-OAuth-2-0-grant-type-扩展登陆方式"><a href="#Abp-VNext-OAuth-2-0-grant-type-扩展登陆方式" class="headerlink" title="Abp-VNext OAuth 2.0  grant_type 扩展登陆方式"></a>Abp-VNext OAuth 2.0  grant_type 扩展登陆方式</h4><h5 id="扩展背景"><a href="#扩展背景" class="headerlink" title="扩展背景"></a>扩展背景</h5><p>   由于项目需要、之前我们一直使用三方客户端进行登陆。然后调用对应的接口、这样对于简单的接口没有，后来我们扩展了数据权限导致、这个就无法通用、客户端就没有办法分数据权限。对于我们的密码登陆客户觉得我们这个太复杂了、正常页面的登陆我们需要验证码 然后用户密码进行加密登陆，所以才有了现在这个方式的。参考文献：<a href="https://blog.csdn.net/csdn102347501/article/details/116524580" target="_blank" rel="noopener">https://blog.csdn.net/csdn102347501/article/details/116524580</a></p><h5 id="动态的获取授权"><a href="#动态的获取授权" class="headerlink" title="动态的获取授权"></a>动态的获取授权</h5><p> /// <summary><br> /// 三方验证码<br> /// </summary><br> /// <returns></returns><br> public async Task<threeverificationcodedto> threeVerificationAsync()<br> {<br>     //10 位验证<br>     //多少位<br>     //jgsoftsdwekdu16o<br>     int verificationCodelength = 16;<br>     ThreeVerificationCodeDto verificationCodeDto = new ThreeVerificationCodeDto();<br>     verificationCodeDto.Sub = System.Guid.NewGuid().ToString(“N”);//取消-直接转换为字符串<br>     var code = GenerateRandomCode(verificationCodelength);<br>     //设置<br>     await DistributedCache.SetAsync(verificationCodeDto.Sub, code, options: new DistributedCacheEntryOptions<br>     {<br>         AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(6)<br>     });<br>     verificationCodeDto.ValidatorCode = code;<br>     return await Task.FromResult(verificationCodeDto);<br> }</threeverificationcodedto></p><p>   /// <summary><br>   /// 生成的验证码的长度<br>   /// </summary><br>   /// <param name="length"><br>   /// <returns></returns><br>   private string GenerateRandomCode(int length)<br>   {<br>       string chars = “QWERTYUIPASDFGHJKLZXCVBNMabcdefghijkmnpqrstuvwxyz23456789”;<br>       Random random = new Random();<br>       return new string(Enumerable.Repeat(chars, length)<br>         .Select(s =&gt; s[random.Next(s.Length)]).ToArray());<br>   }</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>建立常量定义：</p><p>/// <summary><br>/// 定义常量<br>/// </summary></p><p>public class ThreeClientPassWordValidatorConsts<br>{<br>    /// <summary><br>    /// 验证方式<br>    /// </summary><br>    public const string ThreeClientPassWordValidatorGrantTypeName = “threeclentpassword_verify”;</p><pre><code>/// &lt;summary&gt;/// 验证的客户端/// &lt;/summary&gt;public const string ThreeClientPassWordValidatorClient = &quot;client_id&quot;;/// &lt;summary&gt;/// 验证密匙/// &lt;/summary&gt;public const string ThreeClientPassWordValidatorClient_Secret = &quot;client_secret&quot;;/// &lt;summary&gt;/// 用户名/// &lt;/summary&gt;public const string ThreeClientPassWordValidatorUserName = &quot;username&quot;;/// &lt;summary&gt;/// 密码/// &lt;/summary&gt;public const string ThreeClientPassWordValidatorPassWord = &quot;password&quot;;/// &lt;summary&gt;/// 唯一码值【全局贯通】/// &lt;/summary&gt;public const string ThreeClientPassWordValidatorSub= &quot;sub&quot;;/// &lt;summary&gt;/// 安全日志失败编码/// &lt;/summary&gt;public const string SecurityCodeFailed = &quot;SecurityCodeFailed&quot;;</code></pre><p>}</p><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p>/// <summary><br>/// 扩展登陆效验<br>/// </summary><br>public class ThreeClientPassWordTokenGrantValidator : IExtensionGrantValidator<br>{<br>    /// <summary><br>    /// 验证方式<br>    /// </summary><br>    public string GrantType =&gt; ThreeClientPassWordValidatorConsts.ThreeClientPassWordValidatorGrantTypeName;</p><pre><code>protected SignInManager&lt;IdentityUser&gt; SignInManager { get; }protected UserManager&lt;IdentityUser&gt; UserManager { get; }protected IdentitySecurityLogManager IdentitySecurityLogManager { get; }protected ILogger&lt;ResourceOwnerPasswordValidator&lt;IdentityUser&gt;&gt; Logger { get; }protected IStringLocalizer&lt;AbpIdentityServerResource&gt; Localizer { get; }protected IServiceScopeFactory ServiceScopeFactory { get; }protected AbpIdentityOptions AbpIdentityOptions { get; }protected IOptions&lt;IdentityOptions&gt; IdentityOptions { get; }protected IDistributedCache&lt;string&gt; DistributedCache { get; }/// &lt;summary&gt;/// 构造函数注入/// &lt;/summary&gt;/// &lt;param name=&quot;userManager&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;signInManager&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;identitySecurityLogManager&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;logger&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;localizer&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;abpIdentityOptions&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;serviceScopeFactory&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;identityOptions&quot;&gt;&lt;/param&gt;public ThreeClientPassWordTokenGrantValidator(   UserManager&lt;IdentityUser&gt; userManager,   SignInManager&lt;IdentityUser&gt; signInManager,   IdentitySecurityLogManager identitySecurityLogManager,   ILogger&lt;ResourceOwnerPasswordValidator&lt;IdentityUser&gt;&gt; logger,   IStringLocalizer&lt;AbpIdentityServerResource&gt; localizer,   IOptions&lt;AbpIdentityOptions&gt; abpIdentityOptions,   IServiceScopeFactory serviceScopeFactory,   IOptions&lt;IdentityOptions&gt; identityOptions    , IDistributedCache&lt;string&gt; DistributedCache){    UserManager = userManager;    SignInManager = signInManager;    IdentitySecurityLogManager = identitySecurityLogManager;    Logger = logger;    Localizer = localizer;    ServiceScopeFactory = serviceScopeFactory;    AbpIdentityOptions = abpIdentityOptions.Value;    IdentityOptions = identityOptions;    this.DistributedCache = DistributedCache;}/// &lt;summary&gt;/// 进行验证/// &lt;/summary&gt;/// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;/// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt;[UnitOfWork]public async Task ValidateAsync(ExtensionGrantValidationContext context){    using (var scope = ServiceScopeFactory.CreateScope())    {        var raw = context.Request.Raw;        //偏移量        string aesv = string.Empty;        var keyguid = raw.Get(ThreeClientPassWordValidatorConsts.ThreeClientPassWordValidatorSub);        if (string.IsNullOrWhiteSpace(keyguid))        {            context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant, Localizer[&quot;ValidatorSub&quot;]);            //清理缓存            await DistributedCache.RemoveAsync(keyguid);            return;        }        else        {            //判定此keyguid 是否过期            await DistributedCache.RefreshAsync(keyguid);            aesv = await DistributedCache.GetAsync(keyguid);            if (string.IsNullOrWhiteSpace(aesv))            {                context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant, Localizer[&quot;Cache&quot;]);                //清理缓存                await DistributedCache.RemoveAsync(keyguid);                return;            }        }        //用户名        var username = raw.Get(ThreeClientPassWordValidatorConsts.ThreeClientPassWordValidatorUserName);        if (string.IsNullOrWhiteSpace(username))        {            context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant, Localizer[&quot;UserNameAndPwd&quot;]);            //清理缓存            await DistributedCache.RemoveAsync(keyguid);            return;        }        else        {            username = AESOpenSslHelper.AESDecrypt(username, keyguid, aesv);        }        //密码        var Password = raw.Get(ThreeClientPassWordValidatorConsts.ThreeClientPassWordValidatorPassWord);        if (string.IsNullOrWhiteSpace(Password))        {            context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant, Localizer[&quot;UserNameAndPwd&quot;]);            //清理缓存            await DistributedCache.RemoveAsync(keyguid);            return;        }        else        {            Password = AESOpenSslHelper.AESDecrypt(Password, keyguid, aesv);        }         IdentityUser user = null;         if (AbpIdentityOptions.ExternalLoginProviders.Any())        {            foreach (var externalLoginProviderInfo in AbpIdentityOptions.ExternalLoginProviders.Values)            {                var externalLoginProvider = (IExternalLoginProvider)scope.ServiceProvider                    .GetRequiredService(externalLoginProviderInfo.Type);                if (await externalLoginProvider.TryAuthenticateAsync(username, Password))                {                    user = await UserManager.FindByNameAsync(username);                    if (user == null)                    {                        user = await externalLoginProvider.CreateUserAsync(username, externalLoginProviderInfo.Name);                    }                    else                    {                        await externalLoginProvider.UpdateUserAsync(user, externalLoginProviderInfo.Name);                    }                    await SetSuccessResultAsync(context, user, username);                    await DistributedCache.RemoveAsync(keyguid);                    return;                }            }        }        user = await UserManager.FindByNameAsync(username);        string errorDescription;        if (user != null)        {            await IdentityOptions.SetAsync();            var result = await SignInManager.CheckPasswordSignInAsync(user, Password, true);            if (result.Succeeded)            {                if (await IsTfaEnabledAsync(user))                {                    await HandleTwoFactorLoginAsync(context, user, username);                }                else                {                    await SetSuccessResultAsync(context, user, username);                }                await DistributedCache.RemoveAsync(keyguid);                return;            }            if (result.IsLockedOut)            {                Logger.LogInformation(&quot;Authentication failed for username: {username}, reason: locked out&quot;, username);                errorDescription = Localizer[&quot;UserLockedOut&quot;];            }            else if (result.IsNotAllowed)            {                Logger.LogInformation(&quot;Authentication failed for username: {username}, reason: not allowed&quot;, username);                errorDescription = Localizer[&quot;LoginIsNotAllowed&quot;];            }            else            {                Logger.LogInformation(&quot;Authentication failed for username: {username}, reason: invalid credentials&quot;, username);                errorDescription = Localizer[&quot;InvalidUserNameOrPassword&quot;];            }            await IdentitySecurityLogManager.SaveAsync(new IdentitySecurityLogContext            {                Identity = IdentityServerSecurityLogIdentityConsts.IdentityServer,                Action = result.ToIdentitySecurityLogAction(),                UserName = username,                ClientId = await FindClientIdAsync(context)            });        }        else        {            Logger.LogInformation(&quot;No user found matching username: {username}&quot;, username);            errorDescription = Localizer[&quot;InvalidUsername&quot;];            await IdentitySecurityLogManager.SaveAsync(new IdentitySecurityLogContext()            {                Identity = IdentityServerSecurityLogIdentityConsts.IdentityServer,                Action = IdentityServerSecurityLogActionConsts.LoginInvalidUserName,                UserName = username,                ClientId = await FindClientIdAsync(context)            });        }        //清理缓存        await DistributedCache.RemoveAsync(keyguid);        context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant, errorDescription);    }}/// &lt;summary&gt;/// 处理双因子验证登陆/// &lt;/summary&gt;/// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;user&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;protected virtual async Task HandleTwoFactorLoginAsync(ExtensionGrantValidationContext context, IdentityUser user, string username){    var twoFactorProvider = context.Request?.Raw?[&quot;TwoFactorProvider&quot;];    var twoFactorCode = context.Request?.Raw?[&quot;TwoFactorCode&quot;];    if (!twoFactorProvider.IsNullOrWhiteSpace() &amp;&amp; !twoFactorCode.IsNullOrWhiteSpace())    {        var providers = await UserManager.GetValidTwoFactorProvidersAsync(user);        if (providers.Contains(twoFactorProvider) &amp;&amp; await UserManager.VerifyTwoFactorTokenAsync(user, twoFactorProvider, twoFactorCode))        {            await SetSuccessResultAsync(context, user, username);            return;        }        Logger.LogInformation(&quot;Authentication failed for username: {username}, reason: InvalidAuthenticatorCode&quot;, username);        context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant, Localizer[&quot;InvalidAuthenticatorCode&quot;]);    }    else    {        Logger.LogInformation(&quot;Authentication failed for username: {username}, reason: RequiresTwoFactor&quot;, username);        var twoFactorToken = await UserManager.GenerateUserTokenAsync(user, TokenOptions.DefaultProvider, nameof(SignInResult.RequiresTwoFactor));        context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant, nameof(SignInResult.RequiresTwoFactor),            new Dictionary&lt;string, object&gt;()            {                    {&quot;userId&quot;, user.Id},                    {&quot;twoFactorToken&quot;, twoFactorToken}            });        await IdentitySecurityLogManager.SaveAsync(new IdentitySecurityLogContext        {            Identity = IdentityServerSecurityLogIdentityConsts.IdentityServer,            Action = IdentityServerSecurityLogActionConsts.LoginRequiresTwoFactor,            UserName = username,            ClientId = await FindClientIdAsync(context)        });    }}/// &lt;summary&gt;/// 设置登陆成功/// &lt;/summary&gt;/// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;user&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;protected virtual async Task SetSuccessResultAsync(ExtensionGrantValidationContext context, IdentityUser user, string username){    var sub = await UserManager.GetUserIdAsync(user);    Logger.LogInformation(&quot;Credentials validated for username: {username}&quot;, username);    var additionalClaims = new List&lt;Claim&gt;();    await AddCustomClaimsAsync(additionalClaims, user, context);    context.Result = new GrantValidationResult(        sub,        OidcConstants.AuthenticationMethods.Password,        additionalClaims.ToArray()    );    await IdentitySecurityLogManager.SaveAsync(        new IdentitySecurityLogContext        {            Identity = IdentityServerSecurityLogIdentityConsts.IdentityServer,            Action = IdentityServerSecurityLogActionConsts.LoginSucceeded,            UserName = username,            ClientId = await FindClientIdAsync(context)        }    );}/// &lt;summary&gt;/// 查找客户端/// &lt;/summary&gt;/// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;protected virtual Task&lt;string&gt; FindClientIdAsync(ExtensionGrantValidationContext context){    return Task.FromResult(context.Request?.Client?.ClientId);}/// &lt;summary&gt;/// 验证二次登陆/// &lt;/summary&gt;/// &lt;param name=&quot;user&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;protected virtual async Task&lt;bool&gt; IsTfaEnabledAsync(IdentityUser user)    =&gt; UserManager.SupportsUserTwoFactor &amp;&amp;       await UserManager.GetTwoFactorEnabledAsync(user) &amp;&amp;       (await UserManager.GetValidTwoFactorProvidersAsync(user)).Count &gt; 0;/// &lt;summary&gt;/// 添加身份凭证/// &lt;/summary&gt;/// &lt;param name=&quot;customClaims&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;user&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;protected virtual Task AddCustomClaimsAsync(List&lt;Claim&gt; customClaims, IdentityUser user, ExtensionGrantValidationContext context){    if (user.TenantId.HasValue)    {        customClaims.Add(            new Claim(                AbpClaimTypes.TenantId,                user.TenantId?.ToString()            )        );    }    return Task.CompletedTask;}</code></pre><p>}</p><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><p>登陆Protal 在Client【客户端】 建立threeway_client 客户端</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinIO使用手册</title>
      <link href="/2024/11/13/minio-shi-yong-shou-ce/"/>
      <url>/2024/11/13/minio-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<h3 id="简介-MinIO"><a href="#简介-MinIO" class="headerlink" title="简介 MinIO"></a>简介 MinIO</h3><pre><code>MinIO 是一款高性能、分布式的对象存储系统. 它是一款软件产品, 可以100%的运行在标准硬件。即X86等低成本机器也能够很好的运行MinIO。MinIO提供高性能、S3兼容的对象存储。Minio 是一个基于Go语言的对象存储服务。它实现了大部分亚马逊S3云存储服务接口，可以看做是是S3的开源版本，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。区别于分布式存储系统，minio的特色在于简单、轻量级，对开发者友好，认为存储应该是一个开发问题而不是一个运维问题。MinIO是Kubernetes的原生产品，是唯一一个可在每个公共云、每个Kubernetes发行版、私有云和边缘上使用的对象存储套件。MinIO是软件定义的，在GNU AGPL v3下是100%开源的。MinIO与传统的存储和其他的对象存储不同的是：它一开始就针对性能要求更高的私有云标准进行软件架构设计。因为MinIO一开始就只为对象存储而设计。所以他采用了更易用的方式进行设计，它能实现对象存储所需要的全部功能，在性能上也更加强劲，它不会为了更多的业务功能而妥协，失去MinIO的易用性、高效性。 这样的结果所带来的好处是：它能够更简单的实现局有弹性伸缩能力的原生对象存储服务。MinIO 在最大数量的环境中支持最广泛的用例。自推出云原生以来，MinIO 的软件定义套件在公共云、私有云和 边缘无缝运行- 使其成为混合云和多云对象存储的领导者。凭借行业领先的性能 和可扩展性，MinIO 可以提供一系列用例，包括 AI/ML、分析、备份/恢复以及现代 Web 和移动应用程序。MinIO在传统对象存储用例（例如辅助存储，灾难恢复和归档）方面表现出色。同时，它在机器学习、大数据、私有云、混合云等方面的存储技术上也独树一帜。当然，也不排除数据分析、高性能应用负载、原生云的支持。在中国：阿里巴巴、腾讯、百度、中国联通、华为、中国移动等等9000多家企业也都在使用MinIO产品社区地址 - https://slack.min.io文档地址（文档推荐）- https://docs.min.io中文文档-http://docs.minio.org.cn/docs/博客地址- https://blog.min.io官网地址- https://min.io  https://min.io/docs/minio/container/index.html</code></pre><h3 id="Liunx-中如何安装MINIO"><a href="#Liunx-中如何安装MINIO" class="headerlink" title="Liunx 中如何安装MINIO"></a>Liunx 中如何安装MINIO</h3><h3 id="查询镜像"><a href="#查询镜像" class="headerlink" title="查询镜像"></a>查询镜像</h3><pre><code>docker search minio</code></pre><p>###</p><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><pre><code>docker pull minio/minio</code></pre><h4 id="创建相关数据目录"><a href="#创建相关数据目录" class="headerlink" title="创建相关数据目录"></a>创建相关数据目录</h4><pre><code>mkdir -p D:/minio/datamkdir -p D:/minio/config</code></pre><h4 id="镜像run"><a href="#镜像run" class="headerlink" title="镜像run"></a>镜像run</h4><pre><code>docker run -p 9000:9000 -p 9001:9001 -d --name minio -v D:/minio/data:/data -v D:/minio/config:/root/.minio -e &quot;MINIO_ROOT_USER=admin&quot; -e &quot;MINIO_ROOT_PASSWORD=admin@123456&quot; minio/minio server /data --console-address &quot;:9000&quot; --address &quot;:9001&quot;</code></pre><p>参数说明：<br>-v /wz_conf/minio/data:/data 挂载数据目录<br>-v /wz_conf/minio/config:/root/.minio 挂载配置目录<br>-e MINIO_ROOT_USER=admin 配置登陆用户名<br>-e MINIO_ROOT_PASSWORD=admin 配置登陆密码<br>–console-address “:9001” 服务端口为9001</p><h4 id="翻译为中文"><a href="#翻译为中文" class="headerlink" title="翻译为中文"></a>翻译为中文</h4><p>暂时没有找到合适</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>MINIO_ROOT_PASSWORD 强度一定要合适<br>不然会提示错误信息<br>docker安装minio：Access key length should be at least 3, and secret key length at least 8 characters</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql转linq(Linqer)</title>
      <link href="/2024/06/14/sql-zhuan-linq-linqer/"/>
      <url>/2024/06/14/sql-zhuan-linq-linqer/</url>
      
        <content type="html"><![CDATA[<h3 id="Sql转Linq"><a href="#Sql转Linq" class="headerlink" title="Sql转Linq"></a>Sql转Linq</h3><p>由于对linq语法不是很精通、通过工具进行效验</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><pre><code>https://learn.microsoft.com/zh-cn/previous-versions/dotnet/netframework-4.0/bb386987(v=vs.100)?redirectedfrom=MSDN</code></pre><h4 id="如何使用sqlmetal"><a href="#如何使用sqlmetal" class="headerlink" title="如何使用sqlmetal"></a>如何使用sqlmetal</h4><p>下载地址</p><p>注意<br>使用 Visual Studio 的开发人员还可以使用对象关系设计器生成实体类。对于大型数据库，这种命令行方式具有很好的可伸缩性。由于 SqlMetal 是一个命令行工具，因此可以在生成过程中使用它。有关更多信息，请参见 对象关系设计器（O/R 设计器） 和 对象关系设计器（O/R 设计器） 和 对象关系设计器（O/R 设计器）.</p><h4 id="由于通过Linqer生成文件非常慢且容易失败"><a href="#由于通过Linqer生成文件非常慢且容易失败" class="headerlink" title="由于通过Linqer生成文件非常慢且容易失败"></a>由于通过Linqer生成文件非常慢且容易失败</h4><p>通过命令生成</p><pre><code>---.dbmlsqlmetal /conn:server=172.22.1.145,1433;database=JGSRM-v4;uid=sa;pwd=jgsoft@123;TrustServerCertificate=True /dbml:D:\MyDataInfo\SQL转Linq工具\dbmlfile\zongshen.dbml--.designer.cssqlmetal /conn:server=172.22.1.145,1433;database=JGSRM-v4;uid=sa;pwd=jgsoft@123;TrustServerCertificate=True  /code:D:\MyDataInfo\SQL转Linq工具\dbmlfile\zongshen.designer.cs</code></pre><h4 id="在Linqer选择文件路径"><a href="#在Linqer选择文件路径" class="headerlink" title="在Linqer选择文件路径"></a>在Linqer选择文件路径</h4><p>这里就不插入图片</p>]]></content>
      
      
      <categories>
          
          <category> Linq </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Liunx服务器时间和本地时间不一致</title>
      <link href="/2024/06/13/liunx-fu-wu-qi-shi-jian-he-ben-di-shi-jian-bu-yi-zhi/"/>
      <url>/2024/06/13/liunx-fu-wu-qi-shi-jian-he-ben-di-shi-jian-bu-yi-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="Liunx-服务器时间和本地不一致"><a href="#Liunx-服务器时间和本地不一致" class="headerlink" title="Liunx 服务器时间和本地不一致"></a>Liunx 服务器时间和本地不一致</h3><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="第一步-Dockerfile"><a href="#第一步-Dockerfile" class="headerlink" title="第一步 Dockerfile"></a>第一步 Dockerfile</h5><pre><code># 设置上海时区.(Set your own time zone.)ENV TZ=Asia/ShanghaiRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo &#39;$TZ&#39; &gt; /etc/timezone</code></pre><h5 id="第二步-同步网络时间"><a href="#第二步-同步网络时间" class="headerlink" title="第二步 同步网络时间"></a>第二步 同步网络时间</h5><pre><code>首先查看同步时间 timedatectl status</code></pre><pre><code>第二 安装 ntpyum install ntp</code></pre><pre><code>第三:同步时间ntpdate time.nist.gov</code></pre><pre><code>如果失败--查看 ntpd 状态systemctl status ntpd</code></pre><pre><code>如果是 active(dead)重启 ntpd 服务systemctl restart ntpd.service</code></pre>]]></content>
      
      
      <categories>
          
          <category> Liunx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Liunx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#反射执行方法</title>
      <link href="/2024/06/11/c-fan-she-zhi-xing-fang-fa/"/>
      <url>/2024/06/11/c-fan-she-zhi-xing-fang-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="获取当前程序集运行路径"><a href="#获取当前程序集运行路径" class="headerlink" title="获取当前程序集运行路径"></a>获取当前程序集运行路径</h4><pre><code> string currentDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);</code></pre><h4 id="反射执行其方法"><a href="#反射执行其方法" class="headerlink" title="反射执行其方法"></a>反射执行其方法</h4><p>assemblyPath 程序集路径 xxxxx.dll<br>typeName  命名空间.类名<br>methodName 执行方法</p><pre><code>   DirectoryInfo directory = new DirectoryInfo(currentDirectory);   FileInfo[] fileInfos = directory.GetFiles(assemblyPath);   if (fileInfos.Length &gt; 0)   {       try       {           string DirectoryName = fileInfos[0].FullName;           // 加载程序集            Assembly assembly = Assembly.Load(File.ReadAllBytes(DirectoryName));           // 获取类型           Type type = assembly.GetType(typeName);           // 创建实例           object instance = Activator.CreateInstance(type);           // 获取方法           MethodInfo method = type.GetMethod(methodName);           // 执行方法           method.Invoke(instance, null);       }       catch (Exception ex)       {           Console.WriteLine(&quot;发生错误: &quot; + ex.Message);       }   }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中安装ES和Kibana</title>
      <link href="/2024/06/09/docker-zhong-an-zhuang-es-he-kibana/"/>
      <url>/2024/06/09/docker-zhong-an-zhuang-es-he-kibana/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker中安装ES和Kibana"><a href="#Docker中安装ES和Kibana" class="headerlink" title="Docker中安装ES和Kibana"></a>Docker中安装ES和Kibana</h3><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><pre><code>docker pull docker.elastic.co/elasticsearch/elasticsearch:7.14.0</code></pre><h4 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h4><pre><code>docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.14.0</code></pre><h4 id="拉取-Kibana-镜像"><a href="#拉取-Kibana-镜像" class="headerlink" title="拉取 Kibana 镜像"></a>拉取 Kibana 镜像</h4><pre><code>docker pull docker.elastic.co/kibana/kibana:7.14.0 </code></pre><h4 id="创建软连接-link-elasticsearch"><a href="#创建软连接-link-elasticsearch" class="headerlink" title="创建软连接-link elasticsearch"></a>创建软连接-link elasticsearch</h4><pre><code>docker run -d --name kibana --link elasticsearch -p 5601:5601 docker.elastic.co/kibana/kibana:7.14.0</code></pre><h4 id="将-kibana设置中文（可选）"><a href="#将-kibana设置中文（可选）" class="headerlink" title="将 kibana设置中文（可选）"></a>将 kibana设置中文（可选）</h4><h5 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h5><pre><code>docker exec -it 0bcd8fda4c27 /bin/bash</code></pre><h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><p>在config文件夹中找到kibana.yml文件，并用文本编辑器打开。在文件中找到i18n.locale属性，并将其值更改为zh-CN，表示设置为中文。如果找不到该属性，可以在文件中添加以下行：<br>i18n.locale: “zh-CN”</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装SqlServer并开启代理</title>
      <link href="/2024/06/09/docker-an-zhuang-sqlserver-bing-kai-qi-dai-li/"/>
      <url>/2024/06/09/docker-an-zhuang-sqlserver-bing-kai-qi-dai-li/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker中安装SqlServer"><a href="#Docker中安装SqlServer" class="headerlink" title="Docker中安装SqlServer"></a>Docker中安装SqlServer</h3><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><pre><code>docker pull mcr.microsoft.com/mssql/server:2019-latest</code></pre><h4 id="构建sqlserver"><a href="#构建sqlserver" class="headerlink" title="构建sqlserver"></a>构建sqlserver</h4><pre><code>docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;MSSQL_SA_PASSWORD=JGSoft@123456&quot;  -p 1433:1433 -m 2000M --memory 2000M --name sqlserver --hostname sqlserver  -d  mcr.microsoft.com/mssql/server:2019-latest</code></pre><h4 id="查看SqlServer-错误日志"><a href="#查看SqlServer-错误日志" class="headerlink" title="查看SqlServer 错误日志"></a>查看SqlServer 错误日志</h4><pre><code>docker exec -t sqlserver cat /var/opt/mssql/log/errorlog</code></pre><h4 id="连接到-SQL-Server-容器内部"><a href="#连接到-SQL-Server-容器内部" class="headerlink" title="连接到 SQL Server[容器内部]"></a>连接到 SQL Server[容器内部]</h4><pre><code>docker exec -it sqlserver &quot;bash&quot;</code></pre><h4 id="登陆SQL-Server-容器内部"><a href="#登陆SQL-Server-容器内部" class="headerlink" title="登陆SQL Server[容器内部]"></a>登陆SQL Server[容器内部]</h4><pre><code>/opt/mssql-tools/bin/sqlcmd -S localhost -U &lt;userid&gt; -P &quot;&lt;YourNewStrong@Passw0rd&gt;&quot;</code></pre><h4 id="开启SQL-SERVER-代理"><a href="#开启SQL-SERVER-代理" class="headerlink" title="开启SQL SERVER 代理"></a>开启SQL SERVER 代理</h4><pre><code>/opt/mssql/bin/mssql-conf set sqlagent.enabled true然后重启docker restart sqlserver</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle 中大文本和二进制如何存储</title>
      <link href="/2024/06/09/oracle-zhong-da-wen-ben-he-er-jin-zhi-ru-he-cun-chu/"/>
      <url>/2024/06/09/oracle-zhong-da-wen-ben-he-er-jin-zhi-ru-he-cun-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="Oracle中大文版和二进制如何存储"><a href="#Oracle中大文版和二进制如何存储" class="headerlink" title="Oracle中大文版和二进制如何存储"></a>Oracle中大文版和二进制如何存储</h3><h4 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h4><p>最近项目从SqlServer迁移到Oracle 数据中,遇到大文本和二进制流的问题故作为日常的记录、方便以后查阅</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="二进制流"><a href="#二进制流" class="headerlink" title="二进制流"></a>二进制流</h5><pre><code>/// &lt;summary&gt;/// 业务打印模板/// &lt;/summary&gt;builder.Entity&lt;BizType_Report&gt;(b =&gt;{    b.ToTable(&quot;Sys_BizType_Report&quot;, options.Schema);    b.Property(p =&gt; p.RReport).HasColumnType(&quot;BLOB&quot;);    b.ConfigureByConvention();});</code></pre><h5 id="大文本"><a href="#大文本" class="headerlink" title="大文本"></a>大文本</h5><pre><code>builder.Entity&lt;Sys_BaseModuleVueCode&gt;(b =&gt;{    b.ToTable(options.TablePrefix + &quot;BaseModuleVueCode&quot;);    b.Property(p =&gt; p.VueJson).HasColumnType(&quot;CLOB&quot;);});</code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/06/09/linux-rong-qi-zhong-shi-yong-devexpress-bao-gao-sheng-cheng-pdf-shi-skfontmanager-pao-chu-yi-chang/"/>
      <url>/2024/06/09/linux-rong-qi-zhong-shi-yong-devexpress-bao-gao-sheng-cheng-pdf-shi-skfontmanager-pao-chu-yi-chang/</url>
      
        <content type="html"><![CDATA[<hr><p>title: ‘Linux容器中使用DevExpress报告生成PDF时,SKFontManager 抛出异常’<br>top: false<br>cover: false<br>toc: true<br>mathjax: true<br>date: 2024-06-09 09:51:57<br>password:<br>summary: 在项目使用SkiaSharp抛出异常 The type initializer for ‘SkiaSharp.SKFontManager’ threw an exception<br>tags:<br>categories:<br>—随记</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><pre><code>    2024-04-19 10:11:28 [ERR] [Volo.Abp.AspNetCore.Mvc.ExceptionHandling.AbpExceptionFilter] [1] [69] - The type initializer for &#39;SkiaSharp.SKFontManager&#39; threw an exception.    System.TypeInitializationException: The type initializer for &#39;SkiaSharp.SKFontManager&#39; threw an exception.    ---&gt; System.DllNotFoundException: Unable to load shared library &#39;libSkiaSharp&#39; or one of its dependencies. In order to help diagnose loading problems, consider using a tool like strace. If you&#39;re using glibc, consider setting the LD_DEBUG environment variable:     libfontconfig.so.1: cannot open shared object file: No such file or directory    /usr/share/dotnet/shared/Microsoft.NETCore.App/7.0.17/libSkiaSharp.so: cannot open shared object file: No such file or directory    /app/libSkiaSharp.so: cannot open shared object file: No such file or directory    /app/runtimes/linux-x64/native/liblibSkiaSharp.so: cannot open shared object file: No such file or directory    /usr/share/dotnet/shared/Microsoft.NETCore.App/7.0.17/liblibSkiaSharp.so: cannot open shared object file: No such file or directory    /app/liblibSkiaSharp.so: cannot open shared object file: No such file or directory    /app/runtimes/linux-x64/native/libSkiaSharp: cannot open shared object file: No such file or directory    /usr/share/dotnet/shared/Microsoft.NETCore.App/7.0.17/libSkiaSharp: cannot open shared object file: No such file or directory    /app/libSkiaSharp: cannot open shared object file: No such file or directory    /app/runtimes/linux-x64/native/liblibSkiaSharp: cannot open shared object file: No such file or directory    /usr/share/dotnet/shared/Microsoft.NETCore.App/7.0.17/liblibSkiaSharp: cannot open shared object file: No such file or directory    /app/liblibSkiaSharp: cannot open shared object file: No such file or directory</code></pre><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="在项目引用包"><a href="#在项目引用包" class="headerlink" title="在项目引用包"></a>在项目引用包</h4><pre><code>    &lt;PackageReference Include=&quot;DevExpress.Drawing.Skia&quot; Version=&quot;23.2.3&quot; /&gt;    &lt;PackageReference Include=&quot;DevExpress.Drawing.Skia.es&quot; Version=&quot;23.2.3&quot; /&gt;    &lt;PackageReference Include=&quot;DevExpress.Drawing.Skia.de&quot; Version=&quot;23.2.3&quot; /&gt;    &lt;PackageReference Include=&quot;DevExpress.Drawing.Skia.ja&quot; Version=&quot;23.2.3&quot; /&gt;    &lt;PackageReference Include=&quot;DevExpress.Drawing.es&quot; Version=&quot;23.2.3&quot; /&gt;    &lt;PackageReference Include=&quot;DevExpress.Drawing.de&quot; Version=&quot;23.2.3&quot; /&gt;    &lt;PackageReference Include=&quot;DevExpress.Drawing.ja&quot; Version=&quot;23.2.3&quot; /&gt;    &lt;PackageReference Include=&quot;SkiaSharp&quot; Version=&quot;2.88.8&quot; /&gt;    &lt;PackageReference Include=&quot;SkiaSharp.NativeAssets.Linux.NoDependencies&quot; Version=&quot;2.88.8&quot; /&gt;</code></pre><h4 id="在容器中安装"><a href="#在容器中安装" class="headerlink" title="在容器中安装"></a>在容器中安装</h4><pre><code>apt-get update &amp;&amp; \apt-get install libfreetype6 libfontconfig1 libjpeg62-turbo libpng16-16 zlib1g libx11-6 libxext6 libxrandr2 libxinerama1 libxcursor1 libxi6 </code></pre><h4 id="为了防止每次手工安装-可以写在DockFile中"><a href="#为了防止每次手工安装-可以写在DockFile中" class="headerlink" title="为了防止每次手工安装 可以写在DockFile中"></a>为了防止每次手工安装 可以写在DockFile中</h4><pre><code>RUN apt-get update &amp;&amp; \apt-get install libfreetype6 libfontconfig1 libjpeg62-turbo libpng16-16 zlib1g libx11-6 libxext6 libxrandr2 libxinerama1 libxcursor1 libxi6 </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设置默认语言区</title>
      <link href="/2024/03/28/abp.vnext-she-zhi-mo-ren-yu-yan-qu/"/>
      <url>/2024/03/28/abp.vnext-she-zhi-mo-ren-yu-yan-qu/</url>
      
        <content type="html"><![CDATA[<h3 id="设置默认语言区"><a href="#设置默认语言区" class="headerlink" title="设置默认语言区"></a>设置默认语言区</h3><h4 id="第一种-abp-vnext设置默认区的方式："><a href="#第一种-abp-vnext设置默认区的方式：" class="headerlink" title="第一种: abp.vnext设置默认区的方式："></a>第一种: abp.vnext设置默认区的方式：</h4><pre><code>Configure&lt;AbpLocalizationOptions&gt;(options =&gt;{    options.Resources        .Add&lt;TaskManagementResource&gt;(&quot;zh-Hans&quot;)        .AddVirtualJson(&quot;/JGSoft/Abp/TaskManagement/Localization/Resources&quot;);});</code></pre><h4 id="第二种-通过配置文件设置"><a href="#第二种-通过配置文件设置" class="headerlink" title="第二种:通过配置文件设置"></a>第二种:通过配置文件设置</h4><pre><code>&quot;Settings&quot;: {    &quot;Abp.Localization.DefaultLanguage&quot;: &quot;zh-Hans&quot;  }</code></pre><h4 id="第三种-在Startup文件中设置"><a href="#第三种-在Startup文件中设置" class="headerlink" title="第三种:在Startup文件中设置"></a>第三种:在Startup文件中设置</h4><pre><code>public void Configure(IApplicationBuilder app){    app.InitializeApplication();    //设置默认语言    app.ApplicationServices.GetService&lt;ISettingDefinitionManager&gt;().Get(LocalizationSettingNames.DefaultLanguage).DefaultValue = &quot;zh-Hans&quot;;}</code></pre><h3 id="第四种-在YourProjectNameWebModule文件中设置"><a href="#第四种-在YourProjectNameWebModule文件中设置" class="headerlink" title="第四种:在YourProjectNameWebModule文件中设置"></a>第四种:在YourProjectNameWebModule文件中设置</h3><p>在YourProjectNameWebModule中的OnApplicationInitialization方法中添加如下代码：</p><pre><code>public override void OnApplicationInitialization(ApplicationInitializationContext context){    var app = context.GetApplicationBuilder();    var env = context.GetEnvironment();    // …… 此处省略其他代码    //app.UseAbpRequestLocalization();    // 可以生效    //app.UseAbpRequestLocalization(options =&gt; options.DefaultRequestCulture = new RequestCulture(&quot;zh-Hans&quot;));    // 可以生效    app.UseAbpRequestLocalization(optios =&gt; optios.SetDefaultCulture(&quot;zh-hans&quot;));}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Abp VNext 分布式事物</title>
      <link href="/2023/07/13/abp-vnext-fen-bu-shi-shi-wu/"/>
      <url>/2023/07/13/abp-vnext-fen-bu-shi-shi-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>​      </p><h3 id="ABP-VNext-分布式事物-Two-Phase-Commit"><a href="#ABP-VNext-分布式事物-Two-Phase-Commit" class="headerlink" title="ABP VNext 分布式事物 Two-Phase Commit"></a>ABP VNext 分布式事物 Two-Phase Commit</h3>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/13/abp-vnext-kuo-zhan-icurrentuser-deng-lu-shi-zeng-jia-claim/"/>
      <url>/2023/05/13/abp-vnext-kuo-zhan-icurrentuser-deng-lu-shi-zeng-jia-claim/</url>
      
        <content type="html"><![CDATA[<h3 id="第一步-XXXXX-IdentityServer-中添加需要在ICurrentUser-显示的字段信息"><a href="#第一步-XXXXX-IdentityServer-中添加需要在ICurrentUser-显示的字段信息" class="headerlink" title="第一步  XXXXX.IdentityServer 中添加需要在ICurrentUser 显示的字段信息"></a>第一步  XXXXX.IdentityServer 中添加需要在ICurrentUser 显示的字段信息</h3><p>IdentityServerDataSeedContributor.cs</p><pre><code> private async Task CreateApiResourcesAsync()    {        var commonApiUserClaims = new[]        {                &quot;email&quot;,                &quot;email_verified&quot;,                &quot;name&quot;,                &quot;phone_number&quot;,                &quot;phone_number_verified&quot;,                &quot;role&quot;,                AbpClaimTypes.Name,                AbpClaimTypes.SurName,                AbpClaimTypes.UserName,                &quot;employeeid&quot;,                &quot;providerid&quot;,                &quot;systemno&quot;            };        foreach (var claimType in commonApiUserClaims)        {            Log.Debug(&quot;查看:&quot; + claimType);        }        await CreateApiResourceAsync(&quot;jgsoft-abp-application&quot;, commonApiUserClaims);    }</code></pre><h3 id="第二步-XXXXX-IdentityServer-DbMigrator"><a href="#第二步-XXXXX-IdentityServer-DbMigrator" class="headerlink" title="第二步  XXXXX..IdentityServer.DbMigrator"></a>第二步  XXXXX..IdentityServer.DbMigrator</h3><p>IdentityServerDataSeedContributor.cs</p><pre><code>    private async Task CreateApiResourcesAsync()    {        var commonApiUserClaims = new[]        {                &quot;email&quot;,                &quot;email_verified&quot;,                &quot;name&quot;,                &quot;phone_number&quot;,                &quot;phone_number_verified&quot;,                &quot;role&quot;,                AbpClaimTypes.Name,                AbpClaimTypes.SurName,                AbpClaimTypes.UserName,                &quot;employeeid&quot;,                &quot;providerid&quot;,                &quot;systemno&quot;            };        //添加声明        await CreateApiResourceAsync(&quot;jgsoft-abp-application&quot;, commonApiUserClaims);    }</code></pre><h3 id="第三步-XXXX-Identity-Domain-替换-AbpUserClaimsPrincipalFactory-CustomUserClaimsPrincipalFactory"><a href="#第三步-XXXX-Identity-Domain-替换-AbpUserClaimsPrincipalFactory-CustomUserClaimsPrincipalFactory" class="headerlink" title="第三步: XXXX..Identity.Domain  替换 AbpUserClaimsPrincipalFactory/CustomUserClaimsPrincipalFactory"></a>第三步: XXXX..Identity.Domain  替换 AbpUserClaimsPrincipalFactory/CustomUserClaimsPrincipalFactory</h3><pre><code>public override async Task&lt;ClaimsPrincipal&gt; CreateAsync(IdentityUser user)    {        var principal = await base.CreateAsync(user);        var identity = principal.Identities.First();        /// add custom claim        /// identityPrincipal.AddClaim(new Claim(XXX, XXX));        if (user.ExtraProperties.ContainsKey(&quot;ProviderId&quot;))        {            identity.AddIfNotContains(new Claim(&quot;providerid&quot;, user.ExtraProperties[&quot;ProviderId&quot;].ToString()));        }        if (user.ExtraProperties.ContainsKey(&quot;EmployeeId&quot;))        {            identity.AddIfNotContains(new Claim(&quot;employeeid&quot;, user.ExtraProperties[&quot;EmployeeId&quot;].ToString()));        }        if (user.ExtraProperties.ContainsKey(&quot;SystemNo&quot;))        {            identity.AddIfNotContains(new Claim(&quot;systemno&quot;, user.ExtraProperties[&quot;SystemNo&quot;].ToString()));        }        return principal;    }</code></pre><h3 id="使用中获取"><a href="#使用中获取" class="headerlink" title="使用中获取"></a>使用中获取</h3><pre><code>        long? employeeid = CurrentUser.FindClaimValue&lt;long&gt;(&quot;employeeid&quot;);        long? providerid = CurrentUser.FindClaimValue&lt;long&gt;(&quot;providerid&quot;);        int? systemno = CurrentUser.FindClaimValue&lt;int&gt;(&quot;systemno&quot;);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/04/23/abp-vnext-kuo-jian-yong-hu-biao/"/>
      <url>/2023/04/23/abp-vnext-kuo-jian-yong-hu-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="EntityFrameworkCore-ExtensionMappings"><a href="#EntityFrameworkCore-ExtensionMappings" class="headerlink" title="EntityFrameworkCore  ExtensionMappings"></a>EntityFrameworkCore  ExtensionMappings</h3><p>public class IdentityEfCoreEntityExtensionMappings<br>{<br>    private static readonly OneTimeRunner OneTimeRunner = new OneTimeRunner();</p><pre><code>public static void Configure(){    OneTimeRunner.Run(() =&gt;            {                ObjectExtensionManager.Instance                    .MapEfCoreProperty&lt;IdentityUser, long?&gt;(                        IdentityUserExtensionConst.ProviderField,                        (etb, prop) =&gt;                        {                            prop.HasMaxLength(IdentityUserExtensionConst.ProviderFieldLength);                        })                    .MapEfCoreProperty&lt;IdentityUser, long?&gt;(                        IdentityUserExtensionConst.EmployeeField,                        (etb, prop) =&gt;                        {                            prop.HasMaxLength(IdentityUserExtensionConst.EmployeeFieldLength);                        })                    .MapEfCoreProperty&lt;IdentityUser, int?&gt;(                        IdentityUserExtensionConst.SystemNoField);            });}</code></pre><p>}</p><h3 id="迁移文件中"><a href="#迁移文件中" class="headerlink" title="迁移文件中"></a>迁移文件中</h3><p>   protected override void OnModelCreating(ModelBuilder modelBuilder)<br>    {<br>        base.OnModelCreating(modelBuilder);<br>        //引用添加的字段<br>        IdentityEfCoreEntityExtensionMappings.Configure();<br>        modelBuilder.ConfigureIdentity();<br>        modelBuilder.ConfigureIdentityServer();<br>    }</p><h3 id="实体添加了我们DTO"><a href="#实体添加了我们DTO" class="headerlink" title="实体添加了我们DTO"></a>实体添加了我们DTO</h3><p>/// <summary><br>/// 扩充 IdentityUser Dto<br>/// </summary><br>public class IdentityDtoExtensions<br>{<br>    private static readonly OneTimeRunner OneTimeRunner = new OneTimeRunner();</p><pre><code>public static void Configure(){    OneTimeRunner.Run(() =&gt;    {        ObjectExtensionManager.Instance            .AddOrUpdateProperty&lt;long?&gt;(                new[]                {                    typeof(IdentityUserDto),                    typeof(IdentityUserCreateDto),                    typeof(IdentityUserUpdateDto),                    typeof(ProfileDto),                    typeof(UpdateProfileDto)                },                IdentityUserExtensionConst.ProviderField            );        ObjectExtensionManager.Instance            .AddOrUpdateProperty&lt;long?&gt;(                new[]                {                    typeof(IdentityUserDto),                    typeof(IdentityUserCreateDto),                    typeof(IdentityUserUpdateDto),                    typeof(ProfileDto),                    typeof(UpdateProfileDto)                },             IdentityUserExtensionConst.EmployeeField            );        ObjectExtensionManager.Instance            .AddOrUpdateProperty&lt;int?&gt;(                new[]                {                    typeof(IdentityUserDto),                    typeof(IdentityUserCreateDto),                    typeof(IdentityUserUpdateDto),                    typeof(ProfileDto),                    typeof(UpdateProfileDto)                },                IdentityUserExtensionConst.SystemNoField            );    });}</code></pre><p>}</p><h3 id="最后一步配置DTO加载项"><a href="#最后一步配置DTO加载项" class="headerlink" title="最后一步配置DTO加载项"></a>最后一步配置DTO加载项</h3><p>public class AbpIdentityApplicationContractsModule : AbpModule<br>{</p><pre><code>    public override void PreConfigureServices(ServiceConfigurationContext context)    {        //配置        IdentityDtoExtensions.Configure();        base.PreConfigureServices(context);    }}</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/07/redis/"/>
      <url>/2023/03/07/redis/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>当出现 StackExchange.Redis.RedisConnectionException: No connection is available to service this operation: EVAL; IOCP: (Busy=0,Free=1000,Min=16,Max=1000), WORKER: (Busy=52,Free=971,Min=16,Max=1023), Local-CPU: n/a </p><p>No connection is available to service this operation: SETEX n:AbpZeroMultiTenantLocalizationDictionaryCache,c:PSAV2#zh-CN#0;<br>远程主机强迫关闭了一个现有的连接。; IOCP: (Busy=0,Free=1000,Min=16,Max=1000), WORKER: (Busy=1,Free=32766,Min=16,Max=32767),<br>Local-CPU: n/a —&gt; StackExchange.Redis.RedisConnectionException: SocketFailure (ReadSocketError/ConnectionReset, last-recv: 20)<br> on 10.18.110.20:6379/Subscription, Idle, last: PING, origin: ReadFromPipe, outstanding: 0, last-read: 40311s ago,<br>last-write: 13s ago, unanswered-write: 40311s ago, keep-alive: 60s, state: ConnectedEstablished, mgr: 8 of 10 available, in: 0,<br>last-heartbeat: 0s ago, last-mbeat: 0s ago, global: 0s ago, v: 2.0.519.65453 —&gt; Pipelines.Sockets.Unofficial.ConnectionResetException:<br>远程主机强迫关闭了一个现有的连接。 —&gt; System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。 在 Pipelines.Sockets.Unofficial.SocketAwaitableEventArgs.<getresult>g__ThrowSocketException|10_0(SocketError e)</getresult></p><p>1、cmd 到redis文件下：执行 redis-cli<br>2、127.0.0.1:6379&gt; info memory<br>大家可以看到,user_momory_human=used_memory_peak_human 指标。这样代表峰值的时候redis内存已经不够用了，导致服务往内存插入数据插不进去，报上述错误.<br>3、查看链接数<br>127.0.0.1:6379&gt;info clients<br>4、设置redis最大缓存<br>127.0.0.1:6379&gt;config set maxmemory 1G<br>我们此时临时解决方案：增加redis最大内存 命令： config set maxmemory 25G </p><p>server : 一般 Redis 服务器信息，包含以下域：<br>redis_version : Redis 服务器版本<br>redis_git_sha1 : Git SHA1<br>redis_git_dirty : Git dirty flag<br>os : Redis 服务器的宿主操作系统<br>arch_bits : 架构（32 或 64 位）<br>multiplexing_api : Redis 所使用的事件处理机制<br>gcc_version : 编译 Redis 时所使用的 GCC 版本<br>process_id : 服务器进程的 PID<br>run_id : Redis 服务器的随机标识符（用于 Sentinel 和集群）<br>tcp_port : TCP/IP 监听端口<br>uptime_in_seconds : 自 Redis 服务器启动以来，经过的秒数<br>uptime_in_days : 自 Redis 服务器启动以来，经过的天数<br>lru_clock : 以分钟为单位进行自增的时钟，用于 LRU 管理</p><p>clients : 已连接客户端信息，包含以下域：<br>connected_clients : 已连接客户端的数量（不包括通过从属服务器连接的客户端）<br>client_longest_output_list : 当前连接的客户端当中，最长的输出列表<br>client_longest_input_buf : 当前连接的客户端当中，最大输入缓存<br>blocked_clients : 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</p><p>memory : 内存信息，包含以下域：<br>used_memory : 由 Redis 分配器分配的内存总量，以字节（byte）为单位<br>used_memory_human : 以人类可读的格式返回 Redis 分配的内存总量<br>used_memory_rss : 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。<br>used_memory_peak : Redis 的内存消耗峰值（以字节为单位）<br>used_memory_peak_human : 以人类可读的格式返回 Redis 的内存消耗峰值<br>used_memory_lua : Lua 引擎所使用的内存大小（以字节为单位）<br>mem_fragmentation_ratio : used_memory_rss 和 used_memory 之间的比率<br>mem_allocator : 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。<br>在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿。<br>当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。<br>内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。<br>当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。<br>当 Redis 释放内存时，分配器可能会，也可能不会，将内存返还给操作系统。<br>如果 Redis 释放了内存，却没有将内存返还给操作系统，那么 used_memory 的值可能和操作系统显示的 Redis 内存占用并不一致。</p><p>查看 used_memory_peak 的值可以验证这种情况是否发生。<br>persistence : RDB 和 AOF 的相关信息<br>stats : 一般统计信息<br>replication : 主/从复制信息<br>cpu : CPU 计算量统计信息<br>commandstats : Redis 命令统计信息<br>cluster : Redis 集群信息<br>keyspace : 数据库相关的统计信息 </p><p>4、127.0.0.1:6379&gt; config set stop-writes-on-bgsave-error no </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows-Docker-安装-RabbitMQ</title>
      <link href="/2023/02/11/windows-docker-an-zhuang-rabbitmq/"/>
      <url>/2023/02/11/windows-docker-an-zhuang-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h3 id="Windows安装RabbitMQ教程"><a href="#Windows安装RabbitMQ教程" class="headerlink" title="Windows安装RabbitMQ教程"></a>Windows安装RabbitMQ教程</h3><p>docker search rabbitmq</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><pre><code>docker pull rabbitmq:3.7.7 rabbitmq:management拉取最新的名为 management docker pull rabbitmq:management</code></pre><h3 id="Run-Docker"><a href="#Run-Docker" class="headerlink" title="Run Docker"></a>Run Docker</h3><pre><code>docker run -d --hostname docker_rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=guest -e RABBITMQ_DEFAULT_PASS=guest -p 15672:15672 -p 5672:5672 rabbitmq:management</code></pre><p>-d 后台运行容器；</p><p>–name 指定容器名；</p><p>-p 指定服务运行的端口（5672：应用访问端口；15672：控制台Web端口号）；</p><p>-v 映射目录或文件(根据自行需要配置)；</p><p>–hostname 主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）；</p><p>-e 指定环境变量；（RABBITMQ_DEFAULT_VHOST：默认虚拟机名；RABBITMQ_DEFAULT_USER：默认的用户名；</p><p>RABBITMQ_DEFAULT_PASS：默认用户名的密码）</p><h3 id="当遇到Guest登录时候-提示not-authorised"><a href="#当遇到Guest登录时候-提示not-authorised" class="headerlink" title="当遇到Guest登录时候 提示not_authorised"></a>当遇到Guest登录时候 提示not_authorised</h3><p>进入容器</p><pre><code>1、docker exec -it 容器Id /bin/bash添加用户和密码2、rabbitmqctl add_user jgsoft jgsoft@给用户添加administrator的权限3、rabbitmqctl set_user_tags jgsoft administrator</code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows Docker 安装 Redis</title>
      <link href="/2023/02/11/windows-docker-an-zhuang-redis/"/>
      <url>/2023/02/11/windows-docker-an-zhuang-redis/</url>
      
        <content type="html"><![CDATA[<h3 id="Windows安装Redis教程"><a href="#Windows安装Redis教程" class="headerlink" title="Windows安装Redis教程"></a>Windows安装Redis教程</h3><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>1、拉取最新的版本</p><pre><code>docker pull redis:latest</code></pre><p>2、拉取指定版本</p><pre><code>docker pull redis:5.0.14 </code></pre><h4 id="建立文件夹"><a href="#建立文件夹" class="headerlink" title="建立文件夹"></a>建立文件夹</h4><p>为了配置保留数据和配置文件，我们需要在启动的时候把容器中的数据文件、配置文件以及log文件关联到本地，防止删除容器的时候把这些文件一块也删除掉。<br>需要在本地新建redis目录，如下命令</p><pre><code> mkdir -p redis/data</code></pre><p>我们redis的目录中放入一个redis.conf的文件，这个文件可以在以前配置文件或者下载一个redis的安装包都可以找，把它放入进去就可以了，然后启动redis，如下命令</p><h4 id="把-redis-下的文件挂载到本机"><a href="#把-redis-下的文件挂载到本机" class="headerlink" title="把 redis 下的文件挂载到本机"></a>把 redis 下的文件挂载到本机</h4><pre><code>docker run -p 6379:6379 --name redis -v D:\redis\redis.conf:/etc/redis/redis.conf -v D:\redis\data:/data -d redis:5.0.14 redis-server /etc/redis/redis.conf --appendonly yes </code></pre><p> docker run -it -d -p 6380:6380 -p 16380:16380 –privileged=true -v /home/redis/node-6380/conf/redis.conf:/usr/local/etc/redis/redis.conf –privileged=true -v /home/redis/node-6380/data:/data –restart always –name redis-6380 –net myredis –sysctl net.core.somaxconn=1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf</p><h4 id="如何设置Redis的密码？"><a href="#如何设置Redis的密码？" class="headerlink" title="如何设置Redis的密码？"></a>如何设置Redis的密码？</h4><p>1.进入redis的容器<br>docker exec -it 容器ID bash</p><p>2.进入redis目录<br>cd /usr/local/bin</p><p>3.运行命令：<br>redis-cli</p><p>4.查看现有的redis密码：<br>config get requirepass</p><p>5.设置redis密码<br>config set requirepass 123456</p><p>6、当我们设置了密码后再通过config get requirepass 查看密码时会提示：(error) NOAUTH Authentication required<br>这是因为redis设置了密码，我们需要使用密码来进行验证之后再来对redis客户端进行操作，否则我们没有操作redis缓存数据库的权限。</p><pre><code>auth 密码</code></pre><p>auth 密码在执行 config get requirepass 查看密码</p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>1、前面的6379表示本机中的端口，后面的6379表示的容器中的端口。 把容器中6379映射到本机的6379端口上</p><pre><code>-p 6379:6379</code></pre><p>2、 -v表示映射容器中的文件和文件路径到本机上，冒号前面表示的本机文件或目录路径，本机的路径可以写绝对路径和相对路径，冒号后边表示的容器中的文件路径或目录路径</p><pre><code>-v redis/redis.conf:/etc/redis/redis.conf -v redis/data:/data</code></pre><p>3、 -d表示后台启动，使用redis的5.0.14版本的镜像，使用redis-server命令，/etc/redis/redis.conf的配置文件启动redis，因为我们做了配置文件的映射，<br>所以实际上使用的本机中的配置文件不是容器中的配置文件</p><pre><code>-d redis:5.0.14 redis-server /etc/redis/redis.conf</code></pre><p>4、 启动后容器名称是redis</p><pre><code>--name redis</code></pre><p>5、 是否需要持久化</p><pre><code>--appendonly yes</code></pre><h3 id="Window-Docker-搭建Redis集群部署"><a href="#Window-Docker-搭建Redis集群部署" class="headerlink" title="Window Docker 搭建Redis集群部署"></a>Window Docker 搭建Redis集群部署</h3><h3 id="主从复制-方式-集群"><a href="#主从复制-方式-集群" class="headerlink" title="主从复制 方式 集群"></a>主从复制 方式 集群</h3><h4 id="创建虚拟网卡"><a href="#创建虚拟网卡" class="headerlink" title="创建虚拟网卡"></a>创建虚拟网卡</h4><pre class="line-numbers language-bash"><code class="language-bash">docker network create myredis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看Docker-网卡信息"><a href="#查看Docker-网卡信息" class="headerlink" title="查看Docker 网卡信息"></a>查看Docker 网卡信息</h4><pre class="line-numbers language-bash"><code class="language-bash">docker network <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看dockerr网络详细信息"><a href="#查看dockerr网络详细信息" class="headerlink" title="查看dockerr网络详细信息"></a>查看dockerr网络详细信息</h4><pre class="line-numbers language-bash"><code class="language-bash">docker network inspect myredis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>redis 配置文件</p><p>示例</p><pre class="line-numbers language-bash"><code class="language-bash">port 6385bind 0.0.0.0protected-mode nodaemonize noappendonly <span class="token function">yes</span>cluster-enabled <span class="token function">yes</span> cluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip  192.168.176.1cluster-announce-port 6385cluster-announce-bus-port 16385<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>做3主3副</p><p>启动6个Redis 容器,端口依次从6380到6383,并把数据卷挂载到宿主机(持久化,保证Redis节点宕机或容器被意外删除后数据不丢失)</p><p>示例命令</p><pre class="line-numbers language-bash"><code class="language-bash"> docker run -it -d -p 6380:6380 -p 16380:16380 --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6380\conf\redis.conf:/usr/local/etc/redis/redis.conf --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6380\data:/data --restart always --name redis-6380 --net myredis --sysctl net.core.somaxconn<span class="token operator">=</span>1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 第一台 </span> docker run -it -d -p 6380:6380 -p 16380:16380 --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6380\conf\redis.conf:/usr/local/etc/redis/redis.conf --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6380\data:/data --restart always --name redis-6380 --net myredis --sysctl net.core.somaxconn<span class="token operator">=</span>1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf<span class="token comment" spellcheck="true"># 第二台</span> docker run -it -d -p 6381:6381 -p 16381:16381 --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6381\conf\redis.conf:/usr/local/etc/redis/redis.conf --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6381\data:/data --restart always --name redis-6381 --net myredis --sysctl net.core.somaxconn<span class="token operator">=</span>1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf<span class="token comment" spellcheck="true"># 第三台</span> docker run -it -d -p 6382:6382 -p 16382:16382 --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6382\conf\redis.conf:/usr/local/etc/redis/redis.conf --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6382\data:/data --restart always --name redis-6382 --net myredis --sysctl net.core.somaxconn<span class="token operator">=</span>1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf<span class="token comment" spellcheck="true"># 第四台</span> docker run -it -d -p 6383:6383 -p 16383:16383 --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6383\conf\redis.conf:/usr/local/etc/redis/redis.conf --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6383\data:/data --restart always --name redis-6383 --net myredis --sysctl net.core.somaxconn<span class="token operator">=</span>1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf <span class="token comment" spellcheck="true"># 第五台</span> docker run -it -d -p 6384:6384 -p 16384:16384 --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6384\conf\redis.conf:/usr/local/etc/redis/redis.conf --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6384\data:/data --restart always --name redis-6384 --net myredis --sysctl net.core.somaxconn<span class="token operator">=</span>1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf <span class="token comment" spellcheck="true"># 第六台</span> docker run -it -d -p 6385:6385 -p 16385:16385 --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6385\conf\redis.conf:/usr/local/etc/redis/redis.conf --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6385\data:/data --restart always --name redis-6385 --net myredis --sysctl net.core.somaxconn<span class="token operator">=</span>1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><p>-it:交互<br>-d:后台运行，容器启动完成后打印容器<br>–privileged:是否让docker 应用容器 获取宿主机root权限（特殊权限-）<br>-p:端口映射<br>-v:文件挂载<br>–sysctl参数来设置系统参数，通过这些参数来调整系统性能<br>–restart always:在容器退出时总是重启容器<br>–name:给容器取名<br>–net myredis:使用我们创建的虚拟网卡 （想详细了解，可以去看看Docker 网络方面知识）</p><h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><p>首先进入任意一个容器<br>docker exec -it redis-6380 bash<br>create –replicas<br>主节点占从节点的比例<br>从3 主3 比例 1<br>从6 主3 比例 0.5<br>从3 主6 比例 2 </p><h4 id="示例命令"><a href="#示例命令" class="headerlink" title="示例命令"></a>示例命令</h4><pre class="line-numbers language-bash"><code class="language-bash">redis-cli --cluster create 192.168.176.1:6380 192.168.176.1:6381 192.168.176.1:6382 192.168.176.1:6383 192.168.176.1:6384 192.168.176.1:6385  --cluster-replicas 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="哨兵模式搭建-一主二从三哨兵"><a href="#哨兵模式搭建-一主二从三哨兵" class="headerlink" title="哨兵模式搭建(一主二从三哨兵)"></a>哨兵模式搭建(一主二从三哨兵)</h3><p>一主两从三哨兵集群,当master节点宕机时,通过哨兵(sentinel)重新推选出新的master节点,保证集群的可用性.<br> <img src="../../public/images/redis/image-1.png" alt="alt text"></p><h4 id="哨兵的主要功能"><a href="#哨兵的主要功能" class="headerlink" title="哨兵的主要功能"></a>哨兵的主要功能</h4><p>1.集群监控：负责监控 Redis master 和 slave 进程是否正常工作。<br>2.消息通知：如果某个 Redis 实例有故障,那么哨兵负责发送消息作为报警通知给管理员。<br>3.故障转移：如果 master node 挂掉了,会自动转移到 slave node 上。<br>4.配置中心：如果故障转移发生了,通知 client 客户端新的 master 地址。</p><p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。<br>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。<br>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了.</p><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><p>哨兵的核心知识：<br>哨兵至少需要 3 个实例，来保证自己的健壮性。<br>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。<br>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 第一台 </span> docker run -it -d -p 6380:6380 -p 16380:16380 --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6380\conf\redis.conf:/usr/local/etc/redis/redis.conf --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6380\data:/data  --name redis-6380  --sysctl net.core.somaxconn<span class="token operator">=</span>1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf<span class="token comment" spellcheck="true"># 第二台</span> docker run -it -d -p 6381:6381 -p 16381:16381 --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6381\conf\redis.conf:/usr/local/etc/redis/redis.conf --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6381\data:/data  --name redis-6381 --sysctl net.core.somaxconn<span class="token operator">=</span>1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf<span class="token comment" spellcheck="true"># 第三台</span> docker run -it -d -p 6382:6382 -p 16382:16382 --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6382\conf\redis.conf:/usr/local/etc/redis/redis.conf --privileged<span class="token operator">=</span>true -v D:\home\redis\node-6382\data:/data  --name redis-6382  --sysctl net.core.somaxconn<span class="token operator">=</span>1024 redis:5.0.14 redis-server /usr/local/etc/redis/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows Docker 安装 MySql</title>
      <link href="/2023/02/11/windows-docker-an-zhuang-mysql/"/>
      <url>/2023/02/11/windows-docker-an-zhuang-mysql/</url>
      
        <content type="html"><![CDATA[<h3 id="Windows安装MySQL教程"><a href="#Windows安装MySQL教程" class="headerlink" title="Windows安装MySQL教程"></a>Windows安装MySQL教程</h3><p><a href="https://blog.csdn.net/u012643122/article/details/125899829" target="_blank" rel="noopener">https://blog.csdn.net/u012643122/article/details/125899829</a></p><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><pre><code>docker search mysql</code></pre><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><pre><code>5.71、docker pull mysql:5.72、docker pull mysql:latest</code></pre><h3 id="run-mysql-容器-构建"><a href="#run-mysql-容器-构建" class="headerlink" title="run mysql 容器[构建]"></a>run mysql 容器[构建]</h3><pre><code>docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=&quot;123456&quot; -d mysql:5.7</code></pre><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><pre><code>docker exec -it 容器Id /bin/bash</code></pre><h3 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h3><pre><code>mysql -uroot -p</code></pre><h4 id="如何查询master容器的IP？"><a href="#如何查询master容器的IP？" class="headerlink" title="如何查询master容器的IP？"></a>如何查询master容器的IP？</h4><p>首先进入容器</p><pre><code>cat /etc/hosts</code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/02/api-wen-dang-mo-ban/"/>
      <url>/2023/02/02/api-wen-dang-mo-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="整改通知发布"><a href="#整改通知发布" class="headerlink" title="整改通知发布"></a>整改通知发布</h2><p><br><br></p><h3 id="整改通知发布-明细保存"><a href="#整改通知发布-明细保存" class="headerlink" title="整改通知发布_明细保存"></a>整改通知发布_明细保存</h3><table border="2"><tr>   <td style="background: lightgray;">请求路径</td>   <td>/api/services/app/CrudProviderRectification/PRSaveAsync</td></tr><tr>  <td style="background: lightgray;">请求方式</td>   <td>PSOT</td></tr></table> <br><h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><table border="2"><tr style="background: lightgray;">   <td>参数名</td>   <td>数据类型</td>   <td>必填</td>   <td>最大长度</td>   <td>说明</td></tr><tr>   <td>id</td>   <td>long</td>   <td>是</td>   <td>N/A</td>   <td>数据的Id</td></tr></table> <h4 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h4><pre><code></code></pre><br><h4 id="响应参数"><a href="#响应参数" class="headerlink" title="响应参数"></a>响应参数</h4><table border="2"><tr style="background: lightgray;">   <td>参数名</td>   <td>数据类型</td>   <td>必有值</td>   <td>最大长度</td>   <td>说明</td></tr><tr>   <td>id</td>   <td>long</td>   <td>是</td>   <td>N/A</td>   <td>数据的Id</td></tr></table> <h4 id="响应示例"><a href="#响应示例" class="headerlink" title="响应示例"></a>响应示例</h4><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/08/tong-ji-biao-kong-jian-zhan-yong-da-xiao/"/>
      <url>/2022/12/08/tong-ji-biao-kong-jian-zhan-yong-da-xiao/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 统计表空间占用大小<br>top: false<br>cover: false<br>toc: true<br>mathjax: true<br>date: 2022-07-05 08:44:45<br>password:<br>summary: 统计表空间占用大小<br>tags:<br>categories:</p><ul><li>Sql</li></ul><h6 id="解决请求数据大小限制"><a href="#解决请求数据大小限制" class="headerlink" title="解决请求数据大小限制"></a>解决请求数据大小限制</h6><pre class="line-numbers language-bash"><code class="language-bash">CREATE TABLE <span class="token comment" spellcheck="true">#tablespaceinfo</span>    <span class="token punctuation">(</span>      nameinfo VARCHAR<span class="token punctuation">(</span>500<span class="token punctuation">)</span> ,      rowsinfo BIGINT ,      reserved VARCHAR<span class="token punctuation">(</span>200<span class="token punctuation">)</span> ,      datainfo VARCHAR<span class="token punctuation">(</span>200<span class="token punctuation">)</span> ,      index_size VARCHAR<span class="token punctuation">(</span>200<span class="token punctuation">)</span> ,      unused VARCHAR<span class="token punctuation">(</span>200<span class="token punctuation">)</span>    <span class="token punctuation">)</span>  DECLARE @tablename VARCHAR<span class="token punctuation">(</span>400<span class="token punctuation">)</span><span class="token punctuation">;</span>  DECLARE Info_cursor CURSORFOR    SELECT  <span class="token string">'['</span> + s.<span class="token punctuation">[</span>name<span class="token punctuation">]</span> +<span class="token string">']'</span> +<span class="token string">'.'</span> + <span class="token string">'['</span> + t.<span class="token punctuation">[</span>name<span class="token punctuation">]</span> + <span class="token string">']'</span>    FROM    sys.tables t    INNER JOIN sys.schemas s ON t.schema_id <span class="token operator">=</span> s.schema_id     WHERE   <span class="token function">type</span> <span class="token operator">=</span> <span class="token string">'U'</span><span class="token punctuation">;</span>  OPEN Info_cursor  FETCH NEXT FROM Info_cursor INTO @tablename  WHILE @@FETCH_STATUS <span class="token operator">=</span> 0    BEGIN         INSERT  INTO <span class="token comment" spellcheck="true">#tablespaceinfo</span>                EXEC sp_spaceused @tablename          FETCH NEXT FROM Info_cursor      INTO @tablename      END CLOSE Info_cursor  DEALLOCATE Info_cursor  --创建临时表CREATE TABLE <span class="token punctuation">[</span><span class="token comment" spellcheck="true">#tmptb]</span>    <span class="token punctuation">(</span>      TableName VARCHAR<span class="token punctuation">(</span>50<span class="token punctuation">)</span> ,      DataInfo BIGINT ,      RowsInfo BIGINT ,      Spaceperrow  AS <span class="token punctuation">(</span> CASE RowsInfo                         WHEN 0 THEN 0                         ELSE CAST<span class="token punctuation">(</span>DataInfo AS decimal<span class="token punctuation">(</span>18,2<span class="token punctuation">))</span>/CAST<span class="token punctuation">(</span>RowsInfo AS decimal<span class="token punctuation">(</span>18,2<span class="token punctuation">))</span>                       END <span class="token punctuation">)</span> PERSISTED    <span class="token punctuation">)</span>--插入数据到临时表INSERT  INTO <span class="token punctuation">[</span><span class="token comment" spellcheck="true">#tmptb]</span>        <span class="token punctuation">(</span> <span class="token punctuation">[</span>TableName<span class="token punctuation">]</span> ,          <span class="token punctuation">[</span>DataInfo<span class="token punctuation">]</span> ,          <span class="token punctuation">[</span>RowsInfo<span class="token punctuation">]</span>        <span class="token punctuation">)</span>        SELECT  <span class="token punctuation">[</span>nameinfo<span class="token punctuation">]</span> ,                CAST<span class="token punctuation">(</span>REPLACE<span class="token punctuation">(</span><span class="token punctuation">[</span>datainfo<span class="token punctuation">]</span>, <span class="token string">'KB'</span>, <span class="token string">''</span><span class="token punctuation">)</span> AS BIGINT<span class="token punctuation">)</span> AS <span class="token string">'datainfo'</span> ,                <span class="token punctuation">[</span>rowsinfo<span class="token punctuation">]</span>        FROM    <span class="token comment" spellcheck="true">#tablespaceinfo</span>        ORDER BY CAST<span class="token punctuation">(</span>REPLACE<span class="token punctuation">(</span>reserved, <span class="token string">'KB'</span>, <span class="token string">''</span><span class="token punctuation">)</span> AS INT<span class="token punctuation">)</span> DESC  --汇总记录SELECT  <span class="token punctuation">[</span>tbspinfo<span class="token punctuation">]</span>.* ,        <span class="token punctuation">[</span>tmptb<span class="token punctuation">]</span>.<span class="token punctuation">[</span>Spaceperrow<span class="token punctuation">]</span> AS <span class="token string">'每行记录大概占用空间（KB）'</span>FROM    <span class="token punctuation">[</span><span class="token comment" spellcheck="true">#tablespaceinfo] AS tbspinfo ,</span>        <span class="token punctuation">[</span><span class="token comment" spellcheck="true">#tmptb] AS tmptb</span>WHERE   <span class="token punctuation">[</span>tbspinfo<span class="token punctuation">]</span>.<span class="token punctuation">[</span>nameinfo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>tmptb<span class="token punctuation">]</span>.<span class="token punctuation">[</span>TableName<span class="token punctuation">]</span>ORDER BY CAST<span class="token punctuation">(</span>REPLACE<span class="token punctuation">(</span><span class="token punctuation">[</span>tbspinfo<span class="token punctuation">]</span>.<span class="token punctuation">[</span>reserved<span class="token punctuation">]</span>, <span class="token string">'KB'</span>, <span class="token string">''</span><span class="token punctuation">)</span> AS INT<span class="token punctuation">)</span> DESC  DROP TABLE <span class="token punctuation">[</span><span class="token comment" spellcheck="true">#tablespaceinfo]</span>DROP TABLE <span class="token punctuation">[</span><span class="token comment" spellcheck="true">#tmptb]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/08/kylin-songzai/"/>
      <url>/2022/12/08/kylin-songzai/</url>
      
        <content type="html"><![CDATA[<hr><p>title: Kylin | 关于写博客的七点反思<br>top: false<br>cover: false<br>toc: true<br>mathjax: true<br>date: 2020-06-11 15:27:31<br>password:<br>summary:<br>tags:<br>categories:</p><ul><li>随笔<blockquote></blockquote></li></ul><h2 id="When？什么时候开始写的？"><a href="#When？什么时候开始写的？" class="headerlink" title="When？什么时候开始写的？"></a>When？什么时候开始写的？</h2><h2 id="Why？为什么会想起来写博客？"><a href="#Why？为什么会想起来写博客？" class="headerlink" title="Why？为什么会想起来写博客？"></a>Why？为什么会想起来写博客？</h2><h2 id="What？都写一些什么主题的博客？"><a href="#What？都写一些什么主题的博客？" class="headerlink" title="What？都写一些什么主题的博客？"></a>What？都写一些什么主题的博客？</h2><h2 id="Who？写出来的博客都是给谁看的？"><a href="#Who？写出来的博客都是给谁看的？" class="headerlink" title="Who？写出来的博客都是给谁看的？"></a>Who？写出来的博客都是给谁看的？</h2><h2 id="Where？都在什么平台写博客呢？"><a href="#Where？都在什么平台写博客呢？" class="headerlink" title="Where？都在什么平台写博客呢？"></a>Where？都在什么平台写博客呢？</h2><h2 id="How？按照什么流程来写博客？"><a href="#How？按照什么流程来写博客？" class="headerlink" title="How？按照什么流程来写博客？"></a>How？按照什么流程来写博客？</h2><h2 id="How-much？要花多少时间和金钱来运营维护？"><a href="#How-much？要花多少时间和金钱来运营维护？" class="headerlink" title="How much？要花多少时间和金钱来运营维护？"></a>How much？要花多少时间和金钱来运营维护？</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用Hexo创建自身博客</title>
      <link href="/2022/12/08/hello-world/"/>
      <url>/2022/12/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="利用Hexo搭建自身的博客"><a href="#利用Hexo搭建自身的博客" class="headerlink" title="利用Hexo搭建自身的博客"></a>利用Hexo搭建自身的博客</h2><h3 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一 准备工作"></a>一 准备工作</h3><p>1、了解Hexo</p><p>​       Hexo是高效的静态站点生成框架，它基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。</p><p>2、搭建Node.js环境</p><p>​      我们了解到Hexo基于Node.js的，那么我们搭建博客网站首先需要安装Node.js环境。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。下载地址：<a href="http://nodejs.cn/download" target="_blank" rel="noopener">http://nodejs.cn/download</a>   测试安装：命令行使用node -v 、mpm -v，查看显示版本号即成功。注意：Node.js 最好安装V12、因为Hexo不支持高版本的Node.js 不然到时候 hexo d 推送的时候就会报错。如果本机需要存在多个node.js版本建议安装NVM 然后切换编译环境。</p><p>NVM 下载地址:<a href="https://nvm.en.softonic.com/" target="_blank" rel="noopener">https://nvm.en.softonic.com/</a></p><pre class="line-numbers language-bash"><code class="language-bash">nvm list  ---查看安装的版本nvm <span class="token function">install</span> 版本  --- 安装 nodejs 版本nvm use 版本 --- 使用版本nvm  uninstall  版本 -- 卸载版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3、安装Hexo博客框架工具</p><p>​     Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下使用如下命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-cli -gyarn add hexo-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4、安装Git版本工具</p><p>​      Git是目前世界上最流行的分布式版本控制系统，是的，没有之一。使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步,下载地址：<a href="https://git-scm.com/downloads。" target="_blank" rel="noopener">https://git-scm.com/downloads。</a></p><p>5、注册Github账号</p><p>​      gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。注册地址：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p><h3 id="二-开始搭建博客"><a href="#二-开始搭建博客" class="headerlink" title="二 开始搭建博客"></a>二 开始搭建博客</h3><p>1、新建GitHub仓库<br>      搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下：</p><p><img src="https://lszai90.github.io/images/hellowordImages/Hexo01.png" alt></p><p>这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：<a href="https://UserName.github.io的形式。" target="_blank" rel="noopener">https://UserName.github.io的形式。</a></p><p>2、创建本地博客站点</p><pre class="line-numbers language-bash"><code class="language-bash">hexo init  myHexoBlog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、创建完成之后，进入项目根目录先安装依赖包：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、下面来测试本地博客站点，在本地博客根目录下使用控制台命令：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo g  //g是generetor的缩写，生成博客hexo s  //s是server的缩写，启动服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入 hexo s 会出现如下图:</p><p><img src="https://lszai90.github.io/images/hellowordImages/Hexo10.png" alt="image-20220619092438712"></p><p>  此时打开浏览器，输入 <a href="http://localhost:4000/，" target="_blank" rel="noopener">http://localhost:4000/，</a> 我们将会看到Hexo自带默认主题显示的博客样式如下:</p><p><img src="https://lszai90.github.io/images/hellowordImages/Hexo02.png" alt></p><p>这里还是我们本地访问的地址、如果想在公网上访问那么就需要在我们这个项目推送到Github上。还记得我们之前在自己仓储上建立的项目吗？首先找到我们的博客仓库，并拷贝仓库地址：</p><p><img src="https://lszai90.github.io/images/hellowordImages/Hexo03.png" alt="Hexo03"></p><p>然后修改本地博客目录的配置：<br>修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下：</p><p><img src="https://lszai90.github.io/images/hellowordImages/Hexo04.png" alt="Hexo04"></p><h3 id="三-主题替换"><a href="#三-主题替换" class="headerlink" title="三 主题替换"></a>三 主题替换</h3><p>1、在Hexo主题页面找到自己喜欢的主题，链接地址：<code>https://hexo.io/themes/</code></p><p><img src="https://lszai90.github.io/images/hellowordImages/Hexo05.png" alt="Hexo05"></p><p>2、进入到主题仓库复制地址：</p><p><img src="https://lszai90.github.io/images/hellowordImages/Hexo06.png" alt="Hexo06"></p><p>3、在自己博客的根目录、控制台执行如下命令：</p><p><img src="https://lszai90.github.io/images/hellowordImages/Hexo07.png" alt="Hexo07"></p><p>4、在 _config.yml 文件下修改主题为刚下载的主题：</p><p><img src="https://lszai90.github.io/images/hellowordImages/Hexo08.png" alt="Hexo08"></p><p>5、重新启动项目就能看到主题改变了</p><p>6、推送项目到Github</p><pre class="line-numbers language-bash"><code class="language-bash">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7、安装上传GitHub的插件：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git —save //安装部署插件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>8、最后我们开启GitHubPages：</p><p><img src="https://lszai90.github.io/images/hellowordImages/Hexo09.png" alt="Hexo09"></p><p>9、基本hexo 操作命令</p><pre class="line-numbers language-bash"><code class="language-bash">hexo clean // 清理hexo new <span class="token string">"文章名称"</span> // 新建文章hexo g // 生成public文件夹hexo s // 开启本地服务器hexo d // 推送到github仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>10、我博客的主题是引用：</p><p><a href="https://github.com/godweiyang/hexo-theme-sungod" target="_blank" rel="noopener">https://github.com/godweiyang/hexo-theme-sungod</a> 感谢阳神的分享</p><p>更多Hexo信息 参考 : <a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git基本操作</title>
      <link href="/2022/11/19/git-ji-ben-cao-zuo/"/>
      <url>/2022/11/19/git-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h4 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h4><p>git config –list –查看本地配置<br>git config –global user.name “用户名” –配置用户名<br>git config –global user.email “邮箱”   –配置邮箱</p><h4 id="初始化仓储"><a href="#初始化仓储" class="headerlink" title="初始化仓储"></a>初始化仓储</h4><p>git init –初始仓库<br>git add *  –添加文件 到暂存区<br>git commit -m “描述” –提交</p><p>—添加仓储<br>git remote add  仓储名字  <a href="https://xxxxxxx/srmtest.git" target="_blank" rel="noopener">https://xxxxxxx/srmtest.git</a></p><p>git push 仓储名字  master</p><p>–获取最新版本<br>git reset –hard HEAD</p><p>–创建分支<br>git checkout -b  分支名称</p><p>–使用指定的本地/远程分支创建分支<br>git checkout -b  新分支名称  原分支名称</p><p>–查看远程分支<br>git branch -r</p><p>–这个命令会从远程仓库获取最新的信息，并删除那些在远程仓库中已经被删除的分支的本地跟踪分支<br>git fetch –prune  执行这个命令</p><p>–我们可以清楚地查看每个分支的最新提交信息以及其与远程分支的关联情况。这对于协作开发和分支管理非常有帮助。<br>git branch -vv </p><p>–删除本地分支<br>git branch -d  分支名字<br>–删除远程分支<br>git push origin –delete 分支名字</p><p>–切换分支(不存在则会依据当前分支创建)<br>git checkout  分支名字</p><p>–推送到指定分支<br>git push 仓储名字 分支名字</p><p>–git 拉取filename to long  注意这个命令需要转到对应目录下的git执行<br>git config –system core.longpaths true </p><p>–获取git (新建分支后通过git fetch获取远程分支)<br>–git fetch</p><p>–解决冲突后继续变基</p><p>git rebase –continue</p><p>–中止变基</p><p>git rebase –abort</p><p>–软重置commit，即保留commit里面的更改和暂存，HEAD代表当前本地最新的提交，后面跟几个^符号就代表前几个提交，亦可以输入指定commit的Hash</p><p>git reset  –soft HEAD^</p><h4 id="还原到某个节点"><a href="#还原到某个节点" class="headerlink" title="还原到某个节点"></a>还原到某个节点</h4><p>–还原到某个节点<br>git reset –hard c8469451</p><p>在强制推送<br>git push -f</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>我猜你心里一定在想：为什么要变干净？<br>应用场景：某一天你正在 feature 分支开发新需求，突然产品经理跑过来说线上有bug，必须马上修复。而此时你的功能开发到一半，于是你急忙想切到 master 分支，然后你就会看到以下报错：<br>因为当前有文件更改了，需要提交commit保持工作区干净才能切分支。由于情况紧急，你只有急忙 commit 上去，commit 信息也随便写了个“暂存代码”，于是该分支提交记录就留了一条黑历史…<br>(真人真事，看过这种提交)<br>如果你学会 stash，就不用那么狼狈了。你只需要：</p><pre><code>  git stash save -m &quot;&quot;</code></pre><p>就这么简单，代码就被存起来了。</p><pre><code>git stash apply或者git stash apply 0  应用哪个节点</code></pre><p>当你修复完线上问题，切回 feature 分支，想恢复代码也只需要：</p><p>–储藏当前的更改<br>git stash save -m “储藏的标题”<br>– 保存当前未commit的代码<br>git stash<br>–保存当前未commit的代码并添加备注<br>git stash save “备注的内容”<br>–列出stash的所有记录<br>git stash list<br>–删除stash的所有记录<br>git stash clear<br>–应用最近一次的stash<br>git stash apply<br>–应用最近一次的stash，随后删除该记录<br>git stash pop<br>–删除最近的一次stash<br>git stash drop</p><p>–应用储藏的代码，0代表最新的储藏，以此类推，亦可以输入 标题或Hash<br>git stash apply 0<br>–删除储藏的代码<br>git stash drop 0</p><p>右键设置PowerShell菜单<br>cmd   regedit 打开注册表<br>HKEY_CLASSES_ROOT—&gt;Directory–&gt;Background—&gt;Shell<br> 新建OpenPowerShellHere 项  数据=PowerShell 打开<br>在新建command  数据=powershell.exe -noexit -command Set-Location -literalPath ‘%V’</p><h4 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h4><p>step1. 先clone a-project项目到本地：</p><pre><code>git clone https://gitlab.com/a-project</code></pre><p>step2. 进入你想添加b-project到a-project的目录：</p><pre><code>cd a-project/sub</code></pre><p>step3. 使用git命令添加子模块：</p><pre><code>git submodule add https://gitlab.com/b-project</code></pre><p>step4. 提交子模块到远程仓库</p><pre><code>git add.git commit -m &quot;add submodule&quot;git push</code></pre><p>set5. 解决子模块没有同步内容</p><pre><code>git submodule initgit submodule syncgit submodule update</code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Office文档结构破坏</title>
      <link href="/2022/11/07/office-wen-dang-jie-gou-po-pi/"/>
      <url>/2022/11/07/office-wen-dang-jie-gou-po-pi/</url>
      
        <content type="html"><![CDATA[<h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>​          突发事件客户导出的excel 用WPS 能打开、Office的打开提示”<strong>已删除的部件: 有 XML 错误的 /xl/sharedStrings.xml。 (字符串) xml 字符非法。 行 32，列 24。已删除的记录: /xl/worksheets/sheet1.xml 部分的 单元格信息</strong>“.然后一阵疯狂的百度。</p><h1 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h1><p>​          首先：看提示我们应该知道 “非法字符破坏了execl的文档结构 导致execl打不开”。不知道是我们国产软件(WPS)把这些问题规避了还是怎么的WPS能打开，OFFICE不能打开。</p><p>xlsx是什么文件的格式:</p><p>​        xlsx是微软“Office Excel”中表格文件的格式；xlsx格式本质上是一个zip文件，主要保存的内容是XML格式的，但文件并不是直接保存在磁盘，而是保存在一个zip文件，然后取扩展名为“.xlsx”；将“.xlsx”格式的文件后缀改为ZIP后解压，解压出来的文件夹中有word这样一个文件夹，它包含了Word文档的大部分内容。</p><p>有了xlsx说明,那我们操作的步骤就有了：</p><p>1、把xlsx 后缀名：改为 .zip或者.rar.</p><p>2、再解压我们得到了此目录：</p><p>![image-20221107110053415](F:\MyDataInfo\My blog 博客\Kylinblog\source_posts\Office文档结构破坏\Office001.png)</p><p>看着是不是很熟悉【注意之前的错误提示】。</p><p>3、点开xl下：</p><p>![image-20221107110256722](F:\MyDataInfo\My blog 博客\Kylinblog\source_posts\Office文档结构破坏\Office002.png)</p><p>4、新建一个execl 打开加载 sharedStrings.xml  然后就会提示你在 哪一行有非法字符</p><p>![image-20221107110352409](F:\MyDataInfo\My blog 博客\Kylinblog\source_posts\Office文档结构破坏\Office003.png)</p><p>5、找到这一行我们怎么来进行找到这个特殊字符的ASCCII码:</p><p>​      利用Sql 查看这个截取出来字符的。</p><p>​     select   char(ASCCII(Substring(‘字段’,0,1)))</p><p>​     UPDATE  表名 SET 字段=REPLACE(字段,CHAR(11),’’)  进行替换。</p><p>​     重新导出: OFFICE也能打开了 非常完美。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问题追根究、总会浮出水面。最重要的解决办法还是通过前端或者后端 把这些非法字符拦截掉不能直接到数据库里面。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Any和Count效率问题</title>
      <link href="/2022/10/05/any-he-count-xiao-lu-wen-ti/"/>
      <url>/2022/10/05/any-he-count-xiao-lu-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>Linq中Count()和Any()引发的效率问题</p><p>当yield循环低于100000次的话，count()和Any()的执行时间差不多，count()时间略大于any()所耗费的时间，<br>当大于100000次的话，count()执行时间就远比Any()执行时间多很多！<br>例如上面的程序执行结果，count耗时2233毫秒，any却只耗时3毫秒<br>原因分析:<br>Any()：<br>public static bool Any<tsource>(this IEnumerable<tsource> source)<br>{<br>    if (source == null)<br>    {<br>        throw Error.ArgumentNull(“source”);<br>    }<br>    using (IEnumerator<tsource> enumerator = source.GetEnumerator())<br>    {<br>        if (enumerator.MoveNext())<br>        {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</tsource></tsource></tsource></p><p>Count():<br>public static int Count<tsource>(this IEnumerable<tsource> source)<br>{<br>    if (source == null)<br>    {<br>        throw Error.ArgumentNull(“source”);<br>    }<br>    ICollection<tsource> is2 = source as ICollection<tsource>;<br>    if (is2 != null)<br>    {<br>        return is2.Count;<br>    }<br>    ICollection is3 = source as ICollection;<br>    if (is3 != null)<br>    {<br>        return is3.Count;<br>    }<br>    int num = 0;<br>    using (IEnumerator<tsource> enumerator = source.GetEnumerator())<br>    {<br>        while (enumerator.MoveNext())<br>        {<br>            num++;<br>        }<br>    }<br>    return num;<br>}<br>无论循环多少次，Any方法执行的时间总是最少的，大概10毫秒之内，我想大家从Any的源码可以知道这个原因，Any方法先判断集合是否为空，然后判断集合是否有数据，只进行一次movenext()，并未进行循环查询集合数量！所以耗费的时间当然一直是最少的了！</tsource></tsource></tsource></tsource></tsource></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>发送及接收邮件</title>
      <link href="/2022/08/30/fa-song-ji-jie-shou-you-jian/"/>
      <url>/2022/08/30/fa-song-ji-jie-shou-you-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>最近在做一个项目时用到了发送邮件及接收邮件。空闲时把他总结下来、希望能帮助其他的人。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>发送邮件我们使用的是SMTP协议、接收邮件使用的是POP3协议，不废话了直接上代码：</p><p>发送邮件:</p><pre><code>namespace KylinEmailCore{    /// &lt;summary&gt;    /// 抽象方法    /// &lt;/summary&gt;    public abstract class PushEamilBase    {        /// &lt;summary&gt;        /// 服务器 Smtp 服务器        /// &lt;/summary&gt;        public virtual string smtpService { get; set; }        /// &lt;summary&gt;        /// 发送邮箱        /// &lt;/summary&gt;        public virtual string sendEmail { get; set; }        /// &lt;summary&gt;        /// 显示名称        /// &lt;/summary&gt;        public virtual string displayName { get; set; }        /// &lt;summary&gt;        /// 发送密码        /// &lt;/summary&gt;        public virtual string sendpwd { get; set; }        /// &lt;summary&gt;        /// 端口        /// &lt;/summary&gt;        public virtual int sendport { get; set; }        /// &lt;summary&gt;        /// 是否使用ssl加密        /// &lt;/summary&gt;        public virtual bool sendssl { get; set; }        //确定smtp服务器地址 实例化一个Smtp客户端        SmtpClient smtpclient = null;//实例化smtp服务器        /// &lt;summary&gt;        /// 构造函数注入必要的参数        /// &lt;/summary&gt;        protected PushEamilBase()        {            smtpService = &quot;smtp.xxxxx.com&quot;; ////默认的Smtp服务            sendEmail = &quot;xxxxx&quot;;///发送邮箱            sendpwd = &quot;xxxx&quot;;//密码            sendport = 25;            displayName = &quot;显示名称&quot;;//Kylin&lt;ls_za@163.com&gt; displayName 就是显示的Kylin            sendssl = false;            this.smtpclient = new SmtpClient();        }        //没有采用方式        public virtual EmailSendBackDto SendEmail(EmailPushDto emailPushDto)        {            EmailSendBackDto emailSendBackDto = new EmailSendBackDto();            smtpclient.Host = smtpService;            smtpclient.Port = sendport;            MailMessage mailMessage = new MailMessage();            mailMessage.From = new MailAddress(sendEmail, displayName);            //主送人            if (emailPushDto.strReceiver != null)            {                for (int i = 0; i &lt; emailPushDto.strReceiver.Count; i++)                {                    if (emailPushDto.strReceiver[i] != &quot;&quot;)                        mailMessage.To.Add(emailPushDto.strReceiver[i]);                }            }            //抄送人            if (emailPushDto.strCReceiver != null)            {                for (int i = 0; i &lt; emailPushDto.strCReceiver.Count; i++)                {                    if (emailPushDto.strCReceiver[i] != &quot;&quot;)                        mailMessage.CC.Add(emailPushDto.strCReceiver[i]);                }            }            mailMessage.Subject = emailPushDto.strSubject;//发送邮件主题            mailMessage.SubjectEncoding = System.Text.Encoding.UTF8;            mailMessage.Body = emailPushDto.strContent;//发送邮件正文             mailMessage.BodyEncoding = System.Text.Encoding.UTF8;            //附件            if (emailPushDto.AttachFile != null)            {                foreach (string key in emailPushDto.AttachFile.Keys)                {                    Attachment file = new Attachment(emailPushDto.AttachFile[key]);                    file.Name = key;                    mailMessage.Attachments.Add(file);                }            }            //邮件发送方式  通过网络发送到smtp服务器            smtpclient.DeliveryMethod = SmtpDeliveryMethod.Network;            //如果服务器支持安全连接，则将安全连接设为true            smtpclient.EnableSsl = sendssl;            try            {                //是否使用默认凭据，若为false，则使用自定义的证书，就是下面的networkCredential实例对象                smtpclient.UseDefaultCredentials = false;                //指定邮箱账号和密码,需要注意的是，这个密码是你在QQ邮箱设置里开启服务的时候给你的那个授权码                NetworkCredential networkCredential = new NetworkCredential(sendEmail, sendpwd);                smtpclient.Credentials = networkCredential;                //发送邮件                //LogManager.WriteLog(&quot;SAI发送邮件:&quot; + mailMessage.ToJson());                smtpclient.Send(mailMessage);                emailSendBackDto.IsSuccess = true;                // to do  发送成功            }            catch (System.Net.Mail.SmtpException ex)            {                // LogManager.WriteLog(&quot;SAI发送邮箱提示错误:&quot; + ex.Message);                emailSendBackDto.IsSuccess = false;                emailSendBackDto.Msg = ex.Message;                // to do  发送失败            }            return emailSendBackDto;        }        //采用html发送方式        public virtual EmailSendBackDto SendHtmlEmail(EmailPushDto emailPushDto)        {            EmailSendBackDto emailSendBackDto = new EmailSendBackDto();            smtpclient.DeliveryMethod = SmtpDeliveryMethod.Network;//指定电子邮件发送方式               //如果服务器支持安全连接，则将安全连接设为true            smtpclient.EnableSsl = sendssl;            smtpclient.Host = smtpService;//邮件服务器            smtpclient.UseDefaultCredentials = true;            smtpclient.Credentials = new NetworkCredential(sendEmail, sendpwd);//用户名、密码             MailMessage mailMessage = new MailMessage();            mailMessage.From = new MailAddress(sendEmail, displayName);            if (emailPushDto.strReceiver != null)            {                for (int i = 0; i &lt; emailPushDto.strReceiver.Count; i++)                {                    mailMessage.To.Add(emailPushDto.strReceiver[i]);                }            }            if (emailPushDto.strCReceiver != null)            {                for (int i = 0; i &lt; emailPushDto.strCReceiver.Count; i++)                {                    mailMessage.CC.Add(emailPushDto.strCReceiver[i]);                }            }            mailMessage.Subject = emailPushDto.strSubject;//邮件标题               mailMessage.Body = emailPushDto.strContent;//发送邮件正文             //mailMessage.Body = emailPushDto.strContent;//邮件内容               mailMessage.BodyEncoding = System.Text.Encoding.UTF8;//邮件内容编码               mailMessage.IsBodyHtml = true;//是否是HTML邮件               mailMessage.Priority = MailPriority.High;//邮件优先级             //附件            if (emailPushDto.AttachFile != null)            {                foreach (string key in emailPushDto.AttachFile.Keys)                {                    Attachment file = new Attachment(emailPushDto.AttachFile[key]);                    file.Name = key;                    mailMessage.Attachments.Add(file);                }            }            try            {                smtpclient.Send(mailMessage);                emailSendBackDto.IsSuccess = true;            }            catch (System.Net.Mail.SmtpException ex)            {                emailSendBackDto.IsSuccess = true;                emailSendBackDto.Msg = ex.Message;            }            return emailSendBackDto;        }    }}</code></pre><p>接收邮件:</p><pre><code>namespace KylinEmailCore{    /// &lt;summary&gt;    /// 接收邮件    /// &lt;/summary&gt;    public class ReveiveEamilBase    {        /// &lt;summary&gt;        /// 存在本地地址        /// &lt;/summary&gt;        public virtual string localfile { get; set; }        /// &lt;summary&gt;        /// 服务器 Smtp 服务器        /// &lt;/summary&gt;        public virtual string smtpService { get; set; }        /// &lt;summary&gt;        /// 发送邮箱        /// &lt;/summary&gt;        public virtual string sendEmail { get; set; }        /// &lt;summary&gt;        /// 发送密码        /// &lt;/summary&gt;        public virtual string sendpwd { get; set; }        /// &lt;summary&gt;        /// 端口        /// &lt;/summary&gt;        public virtual int sendport { get; set; }        /// &lt;summary&gt;        /// 是否使用ssl加密        /// &lt;/summary&gt;        public virtual bool sendssl { get; set; }        //实例化对象        Pop3Client pop3;        public ReveiveEamilBase()        {            smtpService = &quot;pop.qiye.aliyun.com&quot;; //&quot;smtp.mxhichina.com.cn&quot;;//默认的Smtp服务            sendEmail = &quot;sgdsrm@cetccq.com.cn&quot;;// &quot;cetccq_ic@vip.163.com&quot;;//发送邮箱            sendpwd = &quot;Sgd_Srm_12&quot;;//密码            sendport = 110;//端口            sendssl = false;            localfile = &quot;D:\\localfile&quot;;            pop3 = new Pop3Client();        }        /// &lt;summary&gt;        /// 接受邮件 Openpop        /// 邮件接收：.NET中没有POP3邮件接收的类，邮件的内容和格式比复杂，        /// 手动写代码进行解析很麻烦，也容易出错，开发中我们可以借助第三方插件来实现        /// OpenPOP.NET插件的地址：http://sourceforge.net/projects/hpop/        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public virtual List&lt;ReveiveEamilBackDto&gt; ReceiveEmail()        {            List&lt;ReveiveEamilBackDto&gt; reveiveEamilBackDtos = new List&lt;ReveiveEamilBackDto&gt;();            try            {                //链接到邮件服务器                pop3.Connect(smtpService, sendport, sendssl);                //身份验证                pop3.Authenticate(sendEmail, sendpwd);                //读邮件列表                //1.获取邮件的个数                int count = pop3.GetMessageCount();                //2.遍历显示出来                for (int i = 1; i &lt;= count; i++)                {                    Message msg = pop3.GetMessage(i);                    string FromAddress = msg.Headers.From.Address;//发送者的邮箱地址                    string FromDisplayName = msg.Headers.From.DisplayName;//发送者的名子                    DateTime DateSent = msg.Headers.DateSent;//邮件的发送时间                    string Subject = msg.Headers.Subject;//邮件的主题                                                         //获取正文内容，其中包括\n\r这些换行符                    string Body = String.Empty;                    try                    {                        Body = msg.FindFirstPlainTextVersion().GetBodyAsText();                    }                    catch (Exception ex)                    {                    }                    //获取邮件html内容                    //OpenPop.Mime.MessagePart htmlMessage = msg.FindFirstHtmlVersion();                    //string htmlText = htmlMessage.GetBodyAsText();                    //只要有附件才添加到集合                    List&lt;MessagePart&gt; messageParts = msg.FindAllAttachments();                    if (messageParts != null)                    {                        if (messageParts.Count &gt; 0)                        {                            ReveiveEamilBackDto reveiveEamilBackDto = new ReveiveEamilBackDto();                            reveiveEamilBackDto.FromAddress = FromAddress;//发送者的邮箱                            reveiveEamilBackDto.FromDisplayName = FromDisplayName;//发送者的名称                            reveiveEamilBackDto.BodyAsText = Body;//文本                            reveiveEamilBackDto.Subject = Subject;//title                            reveiveEamilBackDto.DateSent = DateSent;//发送日期                            //附件                            reveiveEamilBackDto.fileLists = new List&lt;FileList&gt;();                            foreach (MessagePart item in messageParts)                            {                                FileList fileList = new FileList();                                //判断文件是否存在，不存在则创建的存在                                string sPath = Path.Combine(localfile, &quot;File&quot;);                                if (!System.IO.Directory.Exists(sPath))                                {                                    //创建该文件                                    System.IO.Directory.CreateDirectory(sPath);                                }                                FileInfo fileInfo = new FileInfo(sPath + &quot;\\&quot; + item.FileName);                                //保存附件                                item.Save(fileInfo);                                //添加附件                                fileList.DownDate = DateTime.Now;                                fileList.FileName = item.FileName;                                fileList.FilePath = fileInfo.FullName;                                reveiveEamilBackDto.fileLists.Add(fileList);                            }                            reveiveEamilBackDtos.Add(reveiveEamilBackDto);                        }                    }                    //暂时不需要删除 在测试阶段                    pop3.DeleteMessage(i); //删除邮件                 }                //断开链接                pop3.Disconnect();            }            catch (Exception ex)            {            }            return reveiveEamilBackDtos;        }    }}</code></pre><p>源码：</p><p><a href="https://github.com/lszai90/SendAndReceiveEmail.git" target="_blank" rel="noopener">https://github.com/lszai90/SendAndReceiveEmail.git</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>日行一结，既能利于别人,也能利于己。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web性能优化</title>
      <link href="/2022/08/23/web-xing-neng-you-hua/"/>
      <url>/2022/08/23/web-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Web性能优化】"><a href="#Web性能优化】" class="headerlink" title="[Web性能优化】"></a>[Web性能优化】</h1><h2 id="1-减少HTTP请求"><a href="#1-减少HTTP请求" class="headerlink" title="1. 减少HTTP请求"></a>1. 减少HTTP请求</h2><p>英文：Minimize HTTP Requests<br>终端用户响应的时间中，有80%用于下载各项内容，这部分时间包括下载页面中的图像、样式表、脚本、Flash等。通过减少页面中的元素可以减少HTTP请求的次数，这是提高网页速度的关键步骤。</p><h3 id="1-1-合并文件："><a href="#1-1-合并文件：" class="headerlink" title="1.1. 合并文件："></a>1.1. 合并文件：</h3><p>合并文件是通过把所有的脚本放到一个文件中来减少HTTP请求的方法，例如可以简单地把所有的CSS文件都放入一个样式表中。当脚本 或者样式表在不同页面中使用时需要做不同的修改，这可能会相对比较麻烦，但即便如此也要把这个方法作为改善页面性能的重要一步；</p><h3 id="1-2-CSS-Sprites："><a href="#1-2-CSS-Sprites：" class="headerlink" title="1.2. CSS Sprites："></a>1.2. CSS Sprites：</h3><p>CSS Sprites是减少图像请求的有效方法。把所有的背景图像都放到一个图片文件中，然后通过CSS的<code>background-image</code>和<code>background-position</code>属性来显示图片的不同部分;</p><h3 id="1-3-图片地图："><a href="#1-3-图片地图：" class="headerlink" title="1.3. 图片地图："></a>1.3. 图片地图：</h3><p>图片地图是把多张图片整合到一张图片中。虽然文件的总体大小不会改变，但是可以减少HTTP请求次数。图片地图只有在图片的所有组成 部分在页面中是紧挨在 一起的时候才能使用，如导航栏。确定图片的坐标和可能会比较繁琐且容易出错，同时使用图片地图导航也不具有可读性，因此不推荐这种方法；</p><h3 id="1-4-内联图像："><a href="#1-4-内联图像：" class="headerlink" title="1.4. 内联图像："></a>1.4. 内联图像：</h3><p>内联图像是使用data:URL scheme的方法把图像数据加载页面中，这可能会增加页面的大小。把内联图像放到样式表（可缓存）中可以减少HTTP请求同时又避免增加页面文件的大小，但是内联图像现在还没有得到主流浏览器的支持。</p><p>减少页面的HTTP请求次数是你优化网站性能首先要做的一步，这是改进首次访问用户等待时间的最重要的方法。如同Tenni Theurer的博文《Browser Cahe Usage – Exposed》中所说，HTTP请求在无缓存情况下占去了40%到60%的响应时间。改善HTTP请求，让那些初次访问你网站的人获得更加快速的体验 吧！</p><h2 id="2-利用CDN技术"><a href="#2-利用CDN技术" class="headerlink" title="2. 利用CDN技术"></a>2. 利用CDN技术</h2><p>英文：Use a Content Delivery Network<br>用户与你网站服务器的接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。但是首先我们应该做些什么呢？</p><p>按地域布置网站内容的第一步并不是要尝试重新架构你的网站让他们在分发服务器上正常运行。根据应用的需求来改变网站结构，这可能会包括一些比较复杂 的任务，如在服务器间同步Session状态和合并数据库更新等。要想缩短用户和内容服务器的距离，这些架构步骤可能是不可避免的。</p><p>要记住，在终端用户的响应时间中有80%到90%的响应时间用于下载图像、样式表、脚本、Flash等页面内容。这就是网站性能黄金守则。和重新设 计你的应用程序架构这样比较困难的任务相比，首先来分布静态内容会更好一点。这不仅会缩短响应时间，而且对于内容分发网络来说它更容易实现。</p><p>内容分发网络（Content Delivery Network，CDN）是由一系列分散到各个不同地理位置上的Web服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据 和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数（network hops）和响应速度最快的服务器会被选定。</p><p>一些大型的网络公司拥有自己的CDN，但是使用像Akamai Technologies，Mirror Image Internet， 或者Limelight Networks这样的CDN服务成本却非常高。对于刚刚起步的企业和个人网站来说，可能没有使用CDN的成本预算，但是随着目标用户群的不断扩大和更加 全球化，CDN就是实现快速响应所必需的了。以Yahoo来说，他们转移到CDN上的网站程序静态内容节省了终端用户20%以上的响应时间。使用CDN是 一个只需要相对简单地修改代码实现显著改善网站访问速度的方法。</p><h2 id="3-设置头文件过期或者静态缓存"><a href="#3-设置头文件过期或者静态缓存" class="headerlink" title="3. 设置头文件过期或者静态缓存"></a>3. 设置头文件过期或者静态缓存</h2><p>英文：Add an Expires or a Cache-Control Header<br>这条守则包括两方面的内容：</p><p>对于静态内容：设置文件头过期时间Expires的值为“Never expire”（永不过期）；</p><p>对于动态内容：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求。</p><p>网页内容设计现在越来越丰富，这就意味着页面中要包含更多的脚本、样式表、图片和Flash。第一次访问你页面的用户就意味着进行多次的HTTP请 求，但是通过使用Expires文件头就可以使这样内容具有缓存性。它避免了接下来的页面访问中不必要的HTTP请求。Expires文件头经常用于图像 文件， 但是应该在所有的内容都使用他，包括脚本、样式表和Flash等。</p><p>浏览器（和代理）使用缓存来减少HTTP请求的大小和次数以加快页面访问速度。Web服务器在HTTP响应中使用Expires文件头来告诉客户端 内容需 要缓存多长时间。下面这个例子是一个较长时间的Expires文件头，它告诉浏览器这个响应直到2010年4月15日才过期。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">CopyExpires</span><span class="token punctuation">:</span> Thu<span class="token punctuation">,</span> 15 Apr 2010 20<span class="token punctuation">:</span>00<span class="token punctuation">:</span>00 GMT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你使用的是Apache服务器，可以使用ExpiresDefault来设定相对当前日期的过期时间。</p><p>下面这个例子是使用 ExpiresDefault来设定请求时间后10年过期的文件头：</p><pre class="line-numbers language-vhdl"><code class="language-vhdl">CopyExpiresDefault “<span class="token keyword">access</span> plus <span class="token number">10</span> years”<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要切记，如果使用了Expires文件头，当页面内容改变时就必须改变内容的文件名。依Yahoo!来说我们经常使用这样的步骤：在内容的文件名中加上版本号，yahoo_2.0.6.js。</p><p>使用Expires文件头只有会在用户已经访问过你的网站后才会起作用。当用户首次访问你的网站时这对减少HTTP请求次数来说是无效的，因为浏览 器的缓存是空的。因此这种方法对于你网站性能的改进情况要依据他们“预缓存”存在时对你页面的点击频率（“预缓存”中已经包含了页面中的所有内容）。 Yahoo!建立了一套测量方法，我们发现所有的页面浏览量中有75~85%都有“预缓存”。通过使用Expires文件头，增加了缓存在浏览器中内容的 数量，并且可以在用户接下来的请求中再次使用这些内容，这甚至都不需要通过用户发送一个字节的请求。</p><h2 id="4-Gzip压缩-Gzip-Components"><a href="#4-Gzip压缩-Gzip-Components" class="headerlink" title="4. Gzip压缩(Gzip Components)"></a>4. Gzip压缩(Gzip Components)</h2><p>网络传输中的HTTP请求和应答时间可以通过前端机制得到显著改善。的确，终端用户的带宽、互联网提供者、与对等交换点的靠近程度等都不是网站开发者所能决定的。但是还有其他因素影响着响应时间。通过减小HTTP响应的大小可以节省HTTP响应时间。</p><p>从HTTP/1.1开始，web客户端都默认支持HTTP请求中有Accept-Encoding文件头的压缩格式：</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token symbol">CopyAccept-Encoding</span><span class="token punctuation">:</span> gzip, deflate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果web服务器在请求的文件头中检测到上面的代码，就会以客户端列出的方式压缩响应内容。Web服务器把压缩方式通过响应文件头中的Content- Encoding来返回给浏览器。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token property">CopyContent-Encoding</span><span class="token punctuation">:</span> gzip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Gzip是目前最流行也是最有效的压缩方式。这是由GNU项目开发并通过RFC 1952来标准化的。另外仅有的一个压缩格式是deflate，但是它的使用范围有限效果也稍稍逊色。</p><p>Gzip大概可以减少70%的响应规模。目前大约有90%通过浏览器传输的互联网交换支持gzip格式。如果你使用的是Apache，gzip模块配置和你的版本有关：Apache 1.3使用mod_zip，而Apache 2.x使用moflate。</p><p>浏览器和代理都会存在这样的问题：浏览器期望收到的和实际接收到的内容会存在不匹配的现象。幸好，这种特殊情况随着旧式浏览器使用量的减少在减少。 Apache模块会通过自动添加适当的Vary响应文件头来避免这种状况的出现。</p><p>服务器根据文件类型来选择需要进行gzip压缩的文件，但是这过于限制了可压缩的文件。大多数web服务器会压缩HTML文档。对脚本和样式表进行 压缩同 样也是值得做的事情，但是很多web服务器都没有这个功能。实际上，压缩任何一个文本类型的响应，包括XML和JSON，都值得的。图像和PDF文件由于 已经压缩过了所以不能再进行gzip压缩。如果试图gizp压缩这些文件的话不但会浪费CPU资源还会增加文件的大小。</p><p>Gzip压缩所有可能的文件类型是减少文件体积增加用户体验的简单方法。</p><p>更多详细的GZIP压缩信息请参考我的另外两篇文章：《GZIP页面压缩原理》和《WEB性能优化之GZIP压缩》</p><h2 id="5-把CSS放顶部"><a href="#5-把CSS放顶部" class="headerlink" title="5. 把CSS放顶部"></a>5. 把CSS放顶部</h2><p>英文：Put Stylesheets at the Top</p><p>在研究Yahoo!的性能表现时，我们发现把样式表放到文档的<code>&lt;head /&gt;</code>内部似乎会加快页面的下载速度。这是因为把样式表放到<code>&lt;head /&gt;</code>内会使页面有步骤的加载显示。<br>注重性能的前端服务器往往希望页面有秩序地加载。同时，我们也希望浏览器把已经接收到内容尽可能显示出来。这对于拥有较多内容的页面和网速较慢的用户来说 特别重要。向用户返回可视化的反馈，比如进程指针，已经有了较好的研究并形成了正式文档。在我们的研究中HTML页面就是进程指针。当浏览器有序地加载文 件头、导航栏、顶部的logo等对于等待页面加载的用户来说都可以作为可视化的反馈。这从整体上改善了用户体验。<br>把样式表放在文档底部的问题是在包括Internet Explorer在内的很多浏览器中这会中止内容的有序呈现。浏览器中止呈现是为了避免样式改变引起的页面元素重绘，用户不得不面对一个空白页面。</p><p>HTML规范清楚指出样式表要放包含在页面的<code>&lt;head /&gt;</code>区域内：“和<code>&lt;a /&gt;</code>不同，<code>&lt;link /&gt;</code>只能出现在文档的<code>&lt;head /&gt;</code>区域内，尽管它可以多次使用它”。无论是引起白屏还是出现没有样式化的内容都不值得去尝试。最好的方案就是按照HTML规范在文 档<code>&lt;head /&gt;</code>内加载你的样式表。</p><h2 id="6-把JS放底部"><a href="#6-把JS放底部" class="headerlink" title="6. 把JS放底部"></a>6. 把JS放底部</h2><p>英文：Put Scripts at the Bottom</p><p>脚本带来的问题就是它阻止了页面的平行下载。HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个。如果你的图片放在多个主机名上，你可以在每个并行下载中同时下载2个以上的文件。但是当下载脚本 时，浏览器就不会同时下载其它文件了，即便是主机名不相同。</p><p>在某些情况下把脚本移到页面底部可能不太容易。比如说，如果脚本中使用了document.write来插入页面内容，它就不能被往下移动了。这里可能还会有作用域的问题。很多情况下，都会遇到这方面的问题。</p><p>一个经常用到的替代方法就是使用延迟脚本。DEFER属性表明脚本中没有包含document.write，它告诉浏览器继续显示。不幸的 是，Firefox并不支持DEFER属性。在Internet Explorer中，脚本可能会被延迟但效果也不会像我们所期望的那样。如果脚本可以被延迟，那么它就可以移到页面的底部，这会让你的页面加载的快一点。</p><h2 id="7-避免使用CSS表达式"><a href="#7-避免使用CSS表达式" class="headerlink" title="7. 避免使用CSS表达式"></a>7. 避免使用CSS表达式</h2><p>英文：Avoid CSS Expressions</p><p>CSS表达式是动态设置CSS属性的强大（但危险）方法。Internet Explorer从第5个版本开始支持CSS表达式。下面的例子中，使用CSS表达式可以实现隔一个小时切换一次背景颜色：</p><p>background-color: expression( (new Date()).getHours()%2 ? “#B8D4FF” : “#F08A00″ );</p><p>如上所示，expression中使用了JavaScript表达式。CSS属性根据JavaScript表达式的计算结果来设置。 expression方法在其它浏览器中不起作用，因此在跨浏览器的设计中单独针对Internet Explorer设置时会比较有用。</p><p>表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给CSS表达式增加一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到10000次以上的计算量。</p><p>一个减少CSS表达式计算次数的方法就是使用一次性的表达式，它在第一次运行时将结果赋给指定的样式属性，并用这个属性来代替CSS表达式。如果样 式属性必须在页面周期内动态地改变，使用事件句柄来代替CSS表达式是一个可行办法。如果必须使用CSS表达式，一定要记住它们要计算成千上万次并且可能 会对你页面的性能产生影响。</p><h2 id="8-将JS和CSS外链"><a href="#8-将JS和CSS外链" class="headerlink" title="8. 将JS和CSS外链"></a>8. 将JS和CSS外链</h2><p>英文：Make JavaScript and CSS External</p><p>很多性能规则都是关于如何处理外部文件的。但是，在你采取这些措施前你可能会问到一个更基本的问题：JavaScript和CSS是应该放在外部文件中呢还是把它们放在页面本身之内呢？</p><p>在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。内置在HTML文档中的 JavaScript和CSS则会在每次请求中随HTML文档重新下载。这虽然减少了HTTP请求的次数，却增加了HTML文档的大小。从另一方面来说， 如果外部文件中的JavaScript和CSS被浏览器缓存，在没有增加HTTP请求次数的同时可以减少HTML文档的大小。</p><p>关键问题是，外部JavaScript和CSS文件缓存的频率和请求HTML文档的次数有关。虽然有一定的难度，但是仍然有一些指标可以一测量它。 如果一个会话中用户会浏览你网站中的多个页面，并且这些页面中会重复使用相同的脚本和样式表，缓存外部文件就会带来更大的益处。</p><p>许多网站没有功能建立这些指标。对于这些网站来说，最好的坚决方法就是把JavaScript和CSS作为外部文件引用。比较适合使用内置代码的例 外就是网站的主页，如Yahoo!主页和My Yahoo!。主页在一次会话中拥有较少（可能只有一次）的浏览量，你可以发现内置JavaScript和CSS对于终端用户来说会加快响应时间。</p><p>对于拥有较大浏览量的首页来说，有一种技术可以平衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处。其中一个就是在首页中内 置 JavaScript和CSS，但是在页面下载完成后动态下载外部文件，在子页面中使用到这些文件时，它们已经缓存到浏览器了。</p><h2 id="9-减少DNS查找"><a href="#9-减少DNS查找" class="headerlink" title="9. 减少DNS查找"></a>9. 减少DNS查找</h2><p>英文：Reduce DNS Lookups</p><p>域名系统（DNS）提供了域名和IP的对应关系，就像电话本中人名和他们的电话号码的关系一样。当你在浏览器地址栏中输入 <a href="http://www.52maomao.info时，DNS解析服务器就会返回这个域名对应的IP地址。DNS解析的过程同样也是需要时间的，一般情况下返回给定域名" target="_blank" rel="noopener">www.52maomao.info时，DNS解析服务器就会返回这个域名对应的IP地址。DNS解析的过程同样也是需要时间的，一般情况下返回给定域名</a> 对应的IP地址会花费20到120毫秒的时间，而且在这个过程中浏览器什么都不会做直到DNS查找完毕。</p><p>缓存DNS查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的ISP提供商或者本地局域网控制，但是它同样会在用 户使用的计算机上产生缓存。DNS信息会保留在操作系统的DNS缓存中（微软Windows系统中DNS Client Service），大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。</p><p>Internet Explorer默认情况下对DNS查找记录的缓存时间为30分钟，它在注册表中的键值为DnsCacheTimeout。Firefox对DNS的查找 记录缓存时间为1分钟，它在配置文件中的选项为network.dnsCacheExpiration（Fasterfox把这个选项改为了1小时）。</p><p>当客户端中的DNS缓存都为空时（浏览器和操作系统都为空），DNS查找的次数和页面中主机名的数量相同，这其中包括页面中URL、图片、脚本文 件、样式表、Flash对象等包含的主机名。减少主机名的数量可以减少DNS查找次数。减少主机名的数量还可以减少页面中并行下载的数量。减少DNS查找 次数可以节省响应时间，但是减少并行下载却会增加响应时间。我的指导原则是把这些页面中的内容分割成至少两部分但不超过四部分，这种结果就是在减少DNS 查找次数和保持较高程度并行下载两者之间的权衡了。</p><h2 id="10-减小JS和CSS的体积"><a href="#10-减小JS和CSS的体积" class="headerlink" title="10. 减小JS和CSS的体积"></a>10. 减小JS和CSS的体积</h2><p>英文：Minify JavaScript and CSS</p><p>精简是指从去除代码不必要的字符减少文件大小从而节省下载时间。消减代码时，所有的注释、不需要的空白字符（空格、换行、tab缩进）等都要去掉。 在 JavaScript中，由于需要下载的文件体积变小了从而节省了响应时间。精简JavaScript中目前用到的最广泛的两个工具是JSMin和YUI Compressor。YUI Compressor还可用于精简CSS。</p><p>混淆是另外一种可用于源代码优化的方法。这种方法要比精简复杂一些并且在混淆的过程更易产生问题。在对美国前10大网站的调查中发现，精简也可以缩 小原来代码体积的21%，而混淆可以达到25%。尽管混淆法可以更好地缩减代码，但是对于JavaScript来说精简的风险更小。</p><p>除消减外部的脚本和样式表文件外，<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>代码块也可以并且应该进行消减。即使你用Gzip压缩 过脚本和样式表，精简这些文件仍然可以节省5%以上的空间。由于JavaScript和CSS的功能和体积的增加，消减代码将会获得益处。</p><h2 id="11-避免重定向"><a href="#11-避免重定向" class="headerlink" title="11. 避免重定向"></a>11. 避免重定向</h2><p>英文：Avoid Redirects</p><p>跳转是使用301和302代码实现的。下面是一个响应代码为301的HTTP头：</p><pre class="line-numbers language-bash"><code class="language-bash">CopyHTTP/1.1 301 Moved PermanentlyLocation: http://52maomao.info/demoContent-Type: text/html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>浏览器会把用户指向到Location中指定的URL。头文件中的所有信息在一次跳转中都是必需的，内容部分可以为空。不管他们的名称，301和302 响应都不会被缓存，除非增加一个额外的头选项，如Expires或者Cache-Control来指定它缓存。</p><p><code>&lt;meat /&gt;</code>元素的刷新标签和JavaScript也可以实现URL的跳转，但是如果你必须要跳转的时候，最好的方法就是使用标准的3XXHTTP状态代 码，这主要是为了确保“后退”按钮可以正确地使用。</p><p>但是要记住跳转会降低用户体验。在用户和HTML文档中间增加一个跳转，会拖延页面中所有元素的显示，因为在HTML文件被加载前任何文件（图像、 Flash等）都不会被下载。</p><p>有一种经常被网页开发者忽略却往往十分浪费响应时间的跳转现象。这种现象发生在当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问<code>http: //astrology.yahoo.com/astrology</code> 时，实际上返回的是一个包含301代码的跳转，它指向的是<code>http://astrology.yahoo.com/astrology/</code> （注意末尾的斜杠）。在Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。</p><p>连接新网站和旧网站是跳转功能经常被用到的另一种情况。这种情况下往往要连接网站的不同内容然后根据用户的不同类型（如浏览器类型、用户账号所属类 型）来进行跳转。使用跳转来实现两个网站的切换十分简单，需要的代码量也不多。尽管使用这种方法对于开发者来说可以降低复杂程度，但是它同样降低用户体 验。</p><p>一个可替代方法就是如果两者在同一台服务器上时使用<code>Alias</code>和<code>mod_rewrite</code>和实现。如果是因为域名的不同而采用跳转，那么可以通过使用 <code>Alias</code>或者<code>mod_rewirte</code>建立<code>CNAME</code>（保存一个域名和另外一个域名之间关系的DNS记录）来替代。</p><h2 id="12-删除重复脚本"><a href="#12-删除重复脚本" class="headerlink" title="12. 删除重复脚本"></a>12. 删除重复脚本</h2><p>英文：Remove Duplicate Scripts</p><p>在同一个页面中重复引用JavaScript文件会影响页面的性能。你可能会认为这种情况并不多见。对于美国前10大网站的调查显示其中有两家存在 重复引用脚本的情况。有两种主要因素导致一个脚本被重复引用的奇怪现象发生：团队规模和脚本数量。如果真的存在这种情况，重复脚本会引起不必要的HTTP 请求和无用的JavaScript运算，这降低了网站性能。</p><p>在Internet Explorer中会产生不必要的HTTP请求，而在Firefox却不会。在Internet Explorer中，如果一个脚本被引用两次而且它又不可缓存，它就会在页面加载过程中产生两次HTTP请求。即时脚本可以缓存，当用户重载页面时也会产 生额外的HTTP请求。</p><p>除增加额外的HTTP请求外，多次运算脚本也会浪费时间。在Internet Explorer和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。</p><p>一个避免偶尔发生的两次引用同一脚本的方法是在模板中使用脚本管理模块引用脚本。在HTML页面中使用<code>&lt;script /&gt;</code>标签引用脚本的最常见方法就是：</p><pre class="line-numbers language-xml"><code class="language-xml">Copy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span>”text/javascript”</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span>”menu_1.0.17.js”</span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在PHP中可以通过创建名为insertScript的方法来替代：</p><p>为了防止多次重复引用脚本，这个方法中还应该使用其它机制来处理脚本，如检查所属目录和为脚本文件名中增加版本号以用于Expire文件头等。</p><h2 id="13-配置ETags"><a href="#13-配置ETags" class="headerlink" title="13. 配置ETags"></a>13. 配置ETags</h2><p>英文：Configure ETags<br>Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等）。增加ETag为实体的验证提供了一个比使用“last-modified date（上次编辑时间）”更加灵活的机制。Etag是一个识别内容版本号的唯一字符串。唯一的格式限制就是它必须包含在双引号内。原始服务器通过含有 ETag文件头的响应指定页面内容的ETag。</p><pre class="line-numbers language-yaml"><code class="language-yaml">CopyHTTP/1.1 200 OK<span class="token key atrule">Last-Modified</span><span class="token punctuation">:</span> Tue<span class="token punctuation">,</span> 12 Dec 2006 03<span class="token punctuation">:</span>03<span class="token punctuation">:</span>59 GMT<span class="token key atrule">ETag</span><span class="token punctuation">:</span> “10c24bc<span class="token punctuation">-</span>4ab<span class="token punctuation">-</span>457e1c1f”<span class="token key atrule">Content-Length</span><span class="token punctuation">:</span> <span class="token number">12195</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>稍后，如果浏览器要验证一个文件，它会使用If-None-Match文件头来把ETag传回给原始服务器。在这个例子中，如果ETag匹配，就会返回一 个304状态码，这就节省了12195字节的响应。</p><pre class="line-numbers language-sql"><code class="language-sql">CopyGET <span class="token operator">/</span>i<span class="token operator">/</span>yahoo<span class="token punctuation">.</span>gif HTTP<span class="token operator">/</span><span class="token number">1.1</span>Host: love<span class="token punctuation">.</span>52maomao<span class="token punctuation">.</span>info<span class="token keyword">If</span><span class="token operator">-</span>Modified<span class="token operator">-</span>Since: Tue<span class="token punctuation">,</span> <span class="token number">12</span> <span class="token keyword">Dec</span> <span class="token number">2006</span> <span class="token number">03</span>:<span class="token number">03</span>:<span class="token number">59</span> GMT<span class="token keyword">If</span><span class="token operator">-</span>None<span class="token operator">-</span><span class="token keyword">Match</span>: “<span class="token number">10c24bc</span><span class="token operator">-</span><span class="token number">4ab</span><span class="token operator">-</span><span class="token number">457e1c1f</span>”HTTP<span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">304</span> <span class="token operator">Not</span> Modified<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ETag的问题在于，它是根据可以辨别网站所在的服务器的具有唯一性的属性来生成的。当浏览器从一台服务器上获得页面内容后到另外一台服务器上进行 验证时ETag就会不匹配，这种情况对于使用服务器组和处理请求的网站来说是非常常见的。默认情况下，Apache和IIS都会把数据嵌入ETag中，这 会显著减少多服务器间的文件验证冲突。</p><p>Apache 1.3和2.x中的ETag格式为inode-size-timestamp，即使某个文件在不同的服务器上会处于相同的目录下，文件大小、权限、时间戳等都完全相同，但是在不同服务器上他们的内码也是不同的。</p><p>IIS 5.0和IIS 6.0处理ETag的机制相似。IIS中的ETag格式为Filetimestamp:ChangeNumber。用ChangeNumber来跟踪 IIS配置的改变。网站所用的不同IIS服务器间ChangeNumber也不相同。 不同的服务器上的Apache和IIS即使对于完全相同的内容产生的ETag在也不相同，用户并不会接收到一个小而快的304响应；相反他们会接收一个正 常的200响应并下载全部内容。</p><p>如果你的网站只放在一台服务器上，就不会存在这个问题。但是如果你的网站是架设在多个服务器上，并且使用Apache和IIS产生默认的ETag配 置，你的用户获得页面就会相对慢一点，服务器会传输更多的内容，占用更多的带宽，代理也不会有效地缓存你的网站内容。即使你的内容拥有Expires文件 头，无论用户什么时候点击“刷新”或者“重载”按钮都会发送相应的GET请求。</p><p>如果你没有使用ETag提供的灵活的验证模式，那么干脆把所有的ETag都去掉会更好。Last-Modified文件头验证是基于内容的时间戳 的。去掉 ETag文件头会减少响应和下次请求中文件的大小。微软的这篇支持文稿讲述了如何去掉ETag。在Apache中，只需要在配置文件中简单添加下面一行代 码就可以了：FileETag none。</p><h2 id="14-可缓存的Ajax"><a href="#14-可缓存的Ajax" class="headerlink" title="14. 可缓存的Ajax"></a>14. 可缓存的Ajax</h2><p>Make Ajax Cacheable</p><p>Ajax经常被提及的一个好处就是由于其从后台服务器传输信息的异步性而为用户带来的反馈的即时性。但是，使用Ajax并不能保证用户不会在等待异步的JavaScript和XML响应上花费时间。</p><p>在很多应用中，用户是否需要等待响应取决于Ajax如何来使用。例如，在一个基于Web的Email客户端中，用户必须等待Ajax返回符合他们条件的邮件查询结果。记住一点，“异步”并不异味着“即时”，这很重要。</p><p>为了提高性能，优化Ajax响应是很重要的。提高Ajxa性能的措施中最重要的方法就是使响应具有可缓存性，具体的讨论可以查看《Add an Expires or a Cache-Control Header》。其它的几条规则也同样适用于Ajax：</p><p>1、Gizp压缩文件；</p><p>2、减少DNS查找次数；</p><p>3、精简JavaScript；</p><p>4、避免跳转；</p><p>5、配置ETags。</p><p>让我们来看一个例子：一个Web2.0的Email客户端会使用Ajax来自动完成对用户地址薄的下载。如果用户在上次使用过Email web应用程序后没有对地址薄作任何的修改，而且Ajax响应通过Expire或者Cacke-Control头来实现缓存，那么就可以直接从上一次的缓 存中读取地址薄了。必须告知浏览器是使用缓存中的地址薄还是发送一个新的请求。这可以通过为读取地址薄的Ajax URL增加一个含有上次编辑时间的时间戳来实现，例如，&amp;t=11900241612等。如果地址薄在上次下载后没有被编辑过，时间戳就不变，则 从浏览器的缓存中加载从而减少了一次HTTP请求过程。如果用户修改过地址薄，时间戳就会用来确定新的URL和缓存响应并不匹配，浏览器就会重要请求更新 地址薄。</p><p>即使你的Ajxa响应是动态生成的，哪怕它只适用于一个用户，那么它也应该被缓存起来，这样做可以使你的Web2.0应用程序更加快捷。</p><h2 id="15-尽早刷新输出缓冲"><a href="#15-尽早刷新输出缓冲" class="headerlink" title="15. 尽早刷新输出缓冲"></a>15. 尽早刷新输出缓冲</h2><p>Flush the Buffer Early</p><p>当用户请求一个页面时，无论如何都会花费200到500毫秒用于后台组织HTML文件。在这期间，浏览器会一直空闲等待数据返回。在PHP中，你可 以使用flush()方法，它允许你把已经编译的好的部分HTML响应文件先发送给浏览器，这时浏览器就会可以下载文件中的内容（脚本等）而后台同时处理 剩余的 HTML页面。这样做的效果会在后台烦恼或者前台较空闲时更加明显。</p><p>输出缓冲应用最好的一个地方就是紧跟在<code>&lt;head /&gt;</code>之后，因为HTML的头部分容易生成而且头部往往包含CSS和JavaScript文件，这样浏览器就可以在后台编译剩余HTML的同时并行下载它们。 例子：</p><pre class="line-numbers language-css"><code class="language-css">Copy&lt;!– css, js –>&lt;/head>&lt;body>`&lt;!– content –><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-用GET方式进行AJAX请求"><a href="#16-用GET方式进行AJAX请求" class="headerlink" title="16. 用GET方式进行AJAX请求"></a>16. 用GET方式进行AJAX请求</h2><p>Use GET for AJAX Requests</p><p>Yahoo! Mail团队发现，当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用 GET最为恰当，因为它只需发送一个TCP包（除非你有很多cookie）。IE中URL的最大长度为2K，因此如果你要发送一个超过2K的数据时就不能 使用GET了。</p><p>一个有趣的不同就是POST并不像GET那样实际发送数据。根据HTTP规范，GET意味着“获取”数据，因此当你仅仅获取数据时使用GET更加有意义（从语意上讲也是如此），相反，发送并在服务端保存数据时使用POST。</p><h2 id="17-推迟加载内容"><a href="#17-推迟加载内容" class="headerlink" title="17. 推迟加载内容"></a>17. 推迟加载内容</h2><p>Post-load Components</p><p>你可以仔细看一下你的网页，问问自己“哪些内容是页面呈现时所必需首先加载的？哪些内容和结构可以稍后再加载？</p><p>把整个过程按照onload事件分隔成两部分，JavaScript是一个理想的选择。例如，如果你有用于实现拖放和动画的JavaScript， 那么它 就以等待稍后加载，因为页面上的拖放元素是在初始化呈现之后才发生的。其它的例如隐藏部分的内容（用户操作之后才显现的内容）和处于折叠部分的图像也可以 推迟加载</p><p>工具可以节省你的工作量：YUI Image Loader可以帮你推迟加载折叠部分的图片，YUI Get utility是包含JS和CSS的便捷方法，比如你可以打开Firebug的Net选项卡看一下Yahoo的首页。</p><p>当性能目标和其它网站开发实践一致时就会相得益彰。这种情况下，通过程序提高网站性能的方法告诉我们，在支持JavaScript的情况下，可以先 去除用户体验，不过这要保证你的网站在没有JavaScript也可以正常运行。在确定页面运行正常后，再加载脚本来实现如拖放和动画等更加花哨的效果。</p><h2 id="18-预加载组件"><a href="#18-预加载组件" class="headerlink" title="18. 预加载组件"></a>18. 预加载组件</h2><p>Preload components</p><p>预加载和后加载看起来似乎恰恰相反，但实际上预加载是为了实现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚本）。使用这种方法，当用户要访问下一个页面时，页面中的内容大部分已经加载到缓存中了，因此可以大大改善访问速度。</p><p>下面提供了几种预加载方法：</p><p>无条件加载：触发onload事件时，直接加载额外的页面内容。以Google.com为例，你可以看一下它的spirit image图像是怎样在onload中加载的。这个spirit image图像在google.com主页中是不需要的，但是却可以在搜索结果页面中用到它。</p><p>有条件加载：根据用户的操作来有根据地判断用户下面可能去往的页面并相应的预加载页面内容。在search.yahoo.com中你可以看到如何在你输入内容时加载额外的页面内容。</p><p>有预期的加载：载入重新设计过的页面时使用预加载。这种情况经常出现在页面经过重新设计后用户抱怨“新的页面看起来很酷，但是却比以前慢”。问题可 能出在用户对于你的旧站点建立了完整的缓存，而对于新站点却没有任何缓存内容。因此你可以在访问新站之前就加载一部内容来避免这种结果的出现。在你的旧站 中利用浏览器的空余时间加载新站中用到的图像的和脚本来提高访问速度。</p><h2 id="19-减少DOM元素数量"><a href="#19-减少DOM元素数量" class="headerlink" title="19. 减少DOM元素数量"></a>19. 减少DOM元素数量</h2><p>Reduce the Number of DOM Elements</p><p>一个复杂的页面意味着需要下载更多数据，同时也意味着JavaScript遍历DOM的效率越慢。比如当你增加一个事件句柄时在500和5000个DOM元素中循环效果肯定是不一样的。</p><p>大量的DOM元素的存在意味着页面中有可以不用移除内容只需要替换元素标签就可以精简的部分。你在页面布局中使用表格了吗？你有没有仅仅为了布局而引入更多的<code>&lt;div&gt;</code>元素呢？也许会存在一个适合或者在语意是更贴切的标签可以供你使用。</p><p>YUI CSS utilities可以给你的布局带来巨大帮助：grids.css可以帮你实现整体布局，font.css和reset.css可以帮助你移除浏览器默 认格式。它提供了一个重新审视你页面中标签的机会，比如只有在语意上有意义时才使用<code>&lt;div&gt;</code>，而不是因为它具有换行效果才使用它。</p><p>DOM元素数量很容易计算出来，只需要在Firebug的控制台内输入：</p><pre class="line-numbers language-javascript"><code class="language-javascript">Copydocument<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>‘<span class="token operator">*</span>’<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么多少个DOM元素算是多呢？这可以对照有很好标记使用的类似页面。比如Yahoo!主页是一个内容非常多的页面，但是它只使用了700个元素（HTML标签）。</p><h2 id="20-跨域分离组件"><a href="#20-跨域分离组件" class="headerlink" title="20. 跨域分离组件"></a>20. 跨域分离组件</h2><p>Split Components Across Domains</p><p>把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于DNS查找带来的影响你首先要确保你使用的域名数量在2个到4个之间。例如，你可以 把用到的HTML内容和动态内容放在<a href="http://www.52maomao.info上，而把页面各种组件（图片、脚本、CSS)分别存放在" target="_blank" rel="noopener">www.52maomao.info上，而把页面各种组件（图片、脚本、CSS)分别存放在</a> statics1.52maomao.info和statics.52maomao.info上。</p><p>你可在Tenni Theurer和Patty Chi合写的文章《Maximizing Parallel Downloads in the Carpool Lane》找到更多相关信息。</p><h2 id="21-减少iframe数量"><a href="#21-减少iframe数量" class="headerlink" title="21. 减少iframe数量"></a>21. 减少iframe数量</h2><p>Minimize the Number of iframes</p><p>ifrmae元素可以在父文档中插入一个新的HTML文档。了解iframe的工作理然后才能更加有效地使用它，这一点很重要。</p><iframe>优点：<p>1、解决加载缓慢的第三方内容如图标和广告等的加载问题；</p><p>2、Security sandbox；</p><p>3、并行加载脚本。</p><iframe>的缺点：<p>1、即时内容为空，加载也需要时间；</p><p>2、会阻止页面加载；</p><p>3、没有语意。</p><h2 id="22-不要出现404页面"><a href="#22-不要出现404页面" class="headerlink" title="22. 不要出现404页面"></a>22. 不要出现404页面</h2><p>No 404s</p><p>HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。<br>有些站点把404错误响应页面改为“你是不是要找***”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当 作JavaScript代码来执行。</p><h2 id="23-减小Cookie体积"><a href="#23-减小Cookie体积" class="headerlink" title="23. 减小Cookie体积"></a>23. 减小Cookie体积</h2><p>Reduce Cookie Size</p><p>HTTP coockie可以用于权限验证和个性化身份等多种用途。coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。因此保持coockie尽可能的小以减少用户的响应时间十分重要。</p><p>有关更多信息可以查看Tenni Theurer和Patty Chi的文章《When the Cookie Crumbles》。这们研究中主要包括：</p><p>1、去除不必要的coockie；</p><p>2、使coockie体积尽量小以减少对用户响应的影响；</p><p>3、注意在适应级别的域名上设置coockie以便使子域名不受影响。</p><p>设置合理的过期时间，较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。</p><h2 id="24-对于页面内容使用无coockie域名"><a href="#24-对于页面内容使用无coockie域名" class="headerlink" title="24. 对于页面内容使用无coockie域名"></a>24. 对于页面内容使用无coockie域名</h2><p>Use Cookie-free Domains for Components</p><p>当浏览器在请求中同时请求一张静态的图片和发送coockie时，服务器对于这些coockie不会做任何地使用。因此他们只是因为某些负面因素而创建的 网络传输。所有你应该确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。</p><p>如果你的域名是<a href="http://www.52maomao.info，你可以在static.52maomao.info上存在静态内容。但是，如果你不是在" target="_blank" rel="noopener">www.52maomao.info，你可以在static.52maomao.info上存在静态内容。但是，如果你不是在</a> <a href="http://www.52maomao.info" target="_blank" rel="noopener">www.52maomao.info</a> 上而是在顶级域名52maomao.info设置了coockie，那么所有对于static.52maomao.info的请求都包含coockie。 在这种情 况下，你可以再重新购买一个新的域名来存在静态内容，并且要保持这个域名是无coockie的。Yahoo!使用的是ymig.com，YouTube使 用的是ytimg.com，Amazon使用的是images-anazon.com等等。</p><p>使用无coockie域名存在静态内容的另外一个好处就是一些代理（服务器）可能会拒绝对coockie的内容请求进行缓存。一个相关的建议就是， 如果你想确定应该使用52maomao.info还是<a href="http://www.52maomao.info" target="_blank" rel="noopener">www.52maomao.info</a> 作为你的一主页，你要考虑到coockie带来的影响。忽略掉www会使你除了把coockie设置到<em>.example.org（</em>是泛域名解析，代表 了所有子域名）外没有其它选择，因此出于性能方面的考虑最好是使用带有www的子域名并且在它上面设置coockie。</p><h2 id="25-减少DOM的访问次数"><a href="#25-减少DOM的访问次数" class="headerlink" title="25. 减少DOM的访问次数"></a>25. 减少DOM的访问次数</h2><p>Minimize DOM Access</p><p>使用JavaScript访问DOM元素比较慢，因此为了获得更多的应该页面，应该做到：</p><p>1、缓存已经访问过的有关元素；</p><p>2、线下更新完节点之后再将它们添加到文档树中；</p><p>3、避免使用JavaScript来修改页面布局。</p><p>有关此方面的更多信息请查看Julien Lecomte在YUI专题中的文章《高性能Ajax程序》。</p><h2 id="26-开发灵活的事件处理句柄"><a href="#26-开发灵活的事件处理句柄" class="headerlink" title="26. 开发灵活的事件处理句柄"></a>26. 开发灵活的事件处理句柄</h2><p>(Develop Smart Event Handlers)</p><p>有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。</p><p>你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。</p><p>你可能会希望用DOMContentLoaded事件来代替事件应用程序中的onAvailable方法。</p><h2 id="27-使用-lt-link-gt-而非-import"><a href="#27-使用-lt-link-gt-而非-import" class="headerlink" title="27. 使用&lt; link &gt;而非 @import"></a>27. 使用&lt; link &gt;而非 @import</h2><p>(Choose &lt; link &gt;over @import)</p><p>前面的最佳实现中提到CSS应该放置在顶端以利于有序加载呈现。<br>在IE中，页面底部<code>@import</code>和使用<code>&lt;link&gt;</code>作用是一样的，因此最好不要使用它。</p><h2 id="28-避免过滤器的使用"><a href="#28-避免过滤器的使用" class="headerlink" title="28. 避免过滤器的使用"></a>28. 避免过滤器的使用</h2><p>(Avoid Filters)</p><p>IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。</p><p>完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。</p><h2 id="29-优化图片"><a href="#29-优化图片" class="headerlink" title="29. 优化图片"></a>29. 优化图片</h2><p>(Optimize Images)<br>设计人员完成对页面的设计之后，不要急于将它们上传到web服务器，这里还需要做几件事：</p><p>你可以检查一下你的GIF图片中图像颜色的数量是否和调色板规格一致。 使用imagemagick中下面的命令行很容易检查：identify-verbose image.gif。</p><p>如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。</p><p>尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。由于浏览器支持有限，设计者们往往不太乐意使用PNG格式的图 片，不过这 都是过去的事情了。现在只有一个问题就是在真彩PNG格式中的alpha通道半透明问题，不过同样的，GIF也不是真彩格式也不支持半透明。因此GIF能 做到的，PNG（PNG8）同样也能做到（除了动画）。下面这条简单的命令可以安全地把GIF格式转换为PNG格式：<br>convert image.gif image.png<br>“我们要说的是：给PNG一个施展身手的机会吧！”</p><p>在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如：</p><p>pngcrush image.png -rem alla -reduce -brute result.png</p><p>在所有的 JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息（如 EXIF信息）：<br>jpegtran -copy none -optimize -perfect src.jpg dest.jpg</p><h2 id="30-优化CSS-Sprites"><a href="#30-优化CSS-Sprites" class="headerlink" title="30. 优化CSS Sprites"></a>30. 优化CSS Sprites</h2><p>(Optimize CSS Sprites)<br>在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；</p><p>Spirite 中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；</p><p>便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100的图片为1万像素，而 1000×1000就是100万像素。</p><h2 id="31-不要在HTML中缩放图片"><a href="#31-不要在HTML中缩放图片" class="headerlink" title="31. 不要在HTML中缩放图片"></a>31. 不要在HTML中缩放图片</h2><p>(Don’t Scale Images in HTML)</p><p>不要为了在HTML中设置长宽而使用比实际需要大的图片。如果你需要：<br><code>&lt;img width=”100″ height=”100″ src=”mycat.jpg” alt=”My Cat” /&gt;</code><br>那么你的图片（mycat.jpg）就应该是100×100像素而不是把一个500×500像素的图片缩小使用。</p><h2 id="32-缩小favicon-ico的大小并缓存它"><a href="#32-缩小favicon-ico的大小并缓存它" class="headerlink" title="32. 缩小favicon. ico的大小并缓存它"></a>32. 缩小favicon. ico的大小并缓存它</h2><p>(Make favicon. ico Small and Cacheable )</p><p>favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要 返回一 个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在 onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。</p><p>因此，为了减少favicon.ico带来的弊端，要做到：文件尽量地小，最好小于1K。</p><p>在适当的时候（也就是你不要打算再换 favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。</p><p>Imagemagick可以帮你创建小巧的favicon。</p><h2 id="33-保证组件在25K以下"><a href="#33-保证组件在25K以下" class="headerlink" title="33. 保证组件在25K以下"></a>33. 保证组件在25K以下</h2><p>(Keep Components under 25K )</p><p>这条限制主要是因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重要。</p><p>查看更多信息，请参阅Wayne Shea和Tenni Theurer的文件《Performance Research, Part 5: iPhone Cacheability – Making it Stick》。</p><h2 id="34-将组件打包进一个多部分的文档中"><a href="#34-将组件打包进一个多部分的文档中" class="headerlink" title="34. 将组件打包进一个多部分的文档中"></a>34. 将组件打包进一个多部分的文档中</h2><p>(Pack Components into a Multipart Document)</p><p>把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规则时，首先要确定用户代理是否支持（iPhone就不支持）。</p></iframe></iframe>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vite和webpack区别</title>
      <link href="/2022/08/15/vite-he-webpack-qu-bie/"/>
      <url>/2022/08/15/vite-he-webpack-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>​       最近在学习Vue3 Vite TypeScript 在打包过程中发现了Vite和WebPack 打包区别。</p><h2 id="打包原理区别"><a href="#打包原理区别" class="headerlink" title="打包原理区别"></a>打包原理区别</h2><table><thead><tr><th></th><th>打包过程</th><th>原理</th></tr></thead><tbody><tr><td>webpack</td><td>识别入口-&gt;逐层识别依赖-&gt;分析/转换/编译/输出代码-&gt;打包后的代码</td><td>逐级递归识别依赖，构建依赖图谱-&gt;转化AST语法树-&gt;处理代码-&gt;转换为浏览器可识别的代码</td></tr><tr><td>vite</td><td>-</td><td>基于浏览器原生 ES  module，利用浏览器解析 imports，服务器端按需编译返回</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3+TypeScript</title>
      <link href="/2022/08/10/vue3-typescript/"/>
      <url>/2022/08/10/vue3-typescript/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue介绍"><a href="#Vue介绍" class="headerlink" title="Vue介绍"></a>Vue介绍</h2><p>​         Vue (发音为 /vjuː/，类似 <strong>view</strong>) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p><p><a href="https://cn.vuejs.org/guide/introduction.html" target="_blank" rel="noopener">https://cn.vuejs.org/guide/introduction.html</a></p><h2 id="安装Vue官方脚手架及创建项目"><a href="#安装Vue官方脚手架及创建项目" class="headerlink" title="安装Vue官方脚手架及创建项目"></a>安装Vue官方脚手架及创建项目</h2><h3 id="1、通过Vue-cli-脚手架安装-前提是你需要装yarn或者npm"><a href="#1、通过Vue-cli-脚手架安装-前提是你需要装yarn或者npm" class="headerlink" title="1、通过Vue-cli 脚手架安装[前提是你需要装yarn或者npm]"></a>1、通过Vue-cli 脚手架安装[前提是你需要装yarn或者npm]</h3><p>yarn下载地址：<a href="https://yarn.bootcss.com/docs/install/#windows-stable" target="_blank" rel="noopener">https://yarn.bootcss.com/docs/install/#windows-stable</a></p><pre><code>yarn install -g @vue/clinpm install -g @vue/cli</code></pre><p>安装好后cmd输入以下命名：</p><pre><code>E:\Vue学习项目&gt;vue -V@vue/cli 5.0.8</code></pre><p>出现版本就代表已安装</p><p>通过Vue-Cli创建项目</p><pre><code>vue create hello-vue3cmd 转入项目文件夹运行yarn serve </code></pre><p>这个创建出来的的项目是 Vue+js的项目  默认的是webpackage进行打包</p><h3 id="2、通过Vite创建项目"><a href="#2、通过Vite创建项目" class="headerlink" title="2、通过Vite创建项目"></a>2、通过Vite创建项目</h3><p>什么是Vite</p><p>Vite（法语意为 “快速的”，发音 <code>/vit/</code>，发音同 “veet”）是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：</p><ul><li>一个开发服务器，它基于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noopener">原生 ES 模块</a> 提供了 <a href="https://cn.vitejs.dev/guide/features.html" target="_blank" rel="noopener">丰富的内建功能</a>，如速度快到惊人的 <a href="https://cn.vitejs.dev/guide/features.html#hot-module-replacement" target="_blank" rel="noopener">模块热更新（HMR）</a>。</li><li>一套构建指令，它使用 <a href="https://rollupjs.org/" target="_blank" rel="noopener">Rollup</a> 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。</li></ul><p>Vite 意在提供开箱即用的配置，同时它的 <a href="https://cn.vitejs.dev/guide/api-plugin.html" target="_blank" rel="noopener">插件 API</a> 和 <a href="https://cn.vitejs.dev/guide/api-javascript.html" target="_blank" rel="noopener">JavaScript API</a> 带来了高度的可扩展性，并有完整的类型支持。</p><p>你可以在 <a href="https://cn.vitejs.dev/guide/why.html" target="_blank" rel="noopener">为什么选 Vite</a> 中了解更多关于项目的设计初衷。</p><p>致于Vite我会有一个专门的一篇博客进行讲诉,Vite和webpackage的却别。</p><p>Vite的官网地址：<a href="https://cn.vitejs.dev/guide/" target="_blank" rel="noopener">https://cn.vitejs.dev/guide/</a></p><p>创建项目</p><pre><code>&gt; npm  init vite-app  项目&gt; cd 项目&gt; npm install &gt; npm run dev</code></pre><p>这个创建出来的的项目是 Vue+js的项目</p><h3 id="3、如何通过Vite创建-Vue3-Vite-TypeScript的项目"><a href="#3、如何通过Vite创建-Vue3-Vite-TypeScript的项目" class="headerlink" title="3、如何通过Vite创建 Vue3+Vite+TypeScript的项目"></a>3、如何通过Vite创建 Vue3+Vite+TypeScript的项目</h3><pre><code>&gt;npm create vite&gt;输入项目名&gt;选择Vue&gt;选择Vue-ts&gt;cd vite-project&gt;npm install&gt;npm run dev</code></pre><p>在使用Vue3时： vetur 之前安装的 这个插件禁用掉【这个是支持Vue2】 安装一个Volar 这个是支持Vue3  2者不能兼容【Vue Language Features (Volar)】</p><h3 id="4、如何通过Vite-创建-Vue3-Vite-Ts-React-项目"><a href="#4、如何通过Vite-创建-Vue3-Vite-Ts-React-项目" class="headerlink" title="4、如何通过Vite 创建 Vue3+Vite+Ts+React 项目"></a>4、如何通过Vite 创建 Vue3+Vite+Ts+React 项目</h3><pre><code>npm init vite vite-app --template react</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wsdl.exe与svcutil.exe区别</title>
      <link href="/2022/07/30/wsdl-exe-yu-svcutil-exe-qu-bie/"/>
      <url>/2022/07/30/wsdl-exe-yu-svcutil-exe-qu-bie/</url>
      
        <content type="html"><![CDATA[<h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><p>今天在利用wsdl.exe和svcutil生成 代理类时、发现2者生成出来的代理类结构不一样。嘿嘿 探究一下！</p><h3 id="什么是wsdl"><a href="#什么是wsdl" class="headerlink" title="什么是wsdl"></a>什么是wsdl</h3><p>​       The Web Services Description Language tool generates code for XML Web services and XML Web service clients from WSDL contract files, XSD schemas, and .discomap discovery documents.</p><p>Web服务描述语言工具从WSDL规约文件、XSD架构和.discomap发现文档中生成XML Web服务和XML Web服务客户端的代码。wsdl.exe 默认生成同步和异步的方法。</p><p>语法：</p><pre><code>wsdl [options] {URL | path}</code></pre><table><thead><tr><th align="left">Argument</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><em>URL</em></td><td align="left">The URL to a WSDL contract file (.wsdl), XSD schema file (.xsd), or discovery document (.disco). Note that you cannot specify a URL to a .discomap discovery document.</td></tr><tr><td align="left"><em>path</em></td><td align="left">The path to a local WSDL contract file (.wsdl), XSD schema file (.xsd), or discovery document (.disco or .discomap).</td></tr></tbody></table><table><thead><tr><th align="left">Option</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><strong>/appsettingurlkey:*</strong>key<em>or<strong>/urlkey:*</strong>key</em></td><td align="left">Specifies the configuration key to use in order to read the default value for the URL property when generating code.</td></tr><tr><td align="left"><strong>/appsettingbaseurl:*</strong>baseurl<em>or<strong>/baseurl:*</strong>baseurl</em></td><td align="left">Specifies the base URL to use when calculating the URL fragment. The tool calculates the URL fragment by converting the relative URL from the <em>baseurl</em> argument to the URL in the WSDL document. You must specify the <strong>/appsettingurlkey</strong> option with this option.</td></tr><tr><td align="left"><strong>/d</strong>[<strong>omain</strong>]<strong>:*</strong>domain*</td><td align="left">Specifies the domain name to use when connecting to a server that requires authentication.</td></tr><tr><td align="left"><strong>/l</strong>[<strong>anguage</strong>]<strong>:*</strong>language*</td><td align="left">Specifies the language to use for the generated proxy class. You can specify <strong>CS</strong> (C#; default), <strong>VB</strong> (Visual Basic), <strong>JS</strong> (JScript) or <strong>VJS</strong> (Visual J#) as the language argument. You can also specify the fully qualified name of a class that implements the <a href="https://msdn.microsoft.com/en-us/library/ds075xdx(v=vs.71)" target="_blank" rel="noopener">System.CodeDom.Compiler.CodeDomProvider Class</a>.</td></tr><tr><td align="left"><strong>/n</strong>[<strong>amespace</strong>]<strong>:*</strong>namespace*</td><td align="left">Specifies the namespace for the generated proxy or template. The default namespace is the global namespace.</td></tr><tr><td align="left"><strong>/nologo</strong></td><td align="left">Suppresses the Microsoft startup banner display.</td></tr><tr><td align="left"><strong>/o</strong>[<strong>ut</strong>]<strong>:*</strong>filename*</td><td align="left">Specifies the file in which to save the generated proxy code. The tool derives the default file name from the XML Web service name. The tool saves generated datasets in different files.</td></tr><tr><td align="left"><strong>/parsableerrors</strong></td><td align="left">Displays errors in a format similar to the error reporting format used by language compilers.</td></tr><tr><td align="left"><strong>/p</strong>[<strong>assword</strong>]<strong>:*</strong>password*</td><td align="left">Specifies the password to use when connecting to a server that requires authentication.</td></tr><tr><td align="left"><strong>/protocol:*</strong>protocol*</td><td align="left">Specifies the protocol to implement. You can specify <strong>SOAP</strong> (default), <strong>HttpGet</strong>, <strong>HttpPost</strong>, or a custom protocol specified in the configuration file.</td></tr><tr><td align="left"><strong>/proxy:*</strong>URL*</td><td align="left">Specifies the URL of the proxy server to use for HTTP requests. The default is to use the system proxy setting.</td></tr><tr><td align="left"><strong>/proxydomain:*</strong>domain<em>or<strong>/pd:*</strong>domain</em></td><td align="left">Specifies the domain to use when connecting to a proxy server that requires authentication.</td></tr><tr><td align="left"><strong>/proxypassword:*</strong>password<em>or<strong>/pp:*</strong>password</em></td><td align="left">Specifies the password to use when connecting to a proxy server that requires authentication.</td></tr><tr><td align="left"><strong>/proxyusername:*</strong>username<em>or<strong>/pu:*</strong>username</em></td><td align="left">Specifies the user name to use when connecting to a proxy server that requires authentication.</td></tr><tr><td align="left"><strong>/server</strong></td><td align="left">Generates an abstract class for an XML Web service based on the contracts. The default is to generate client proxy classes.</td></tr><tr><td align="left"><strong>/u</strong>[<strong>sername</strong>]<strong>:*</strong>username*</td><td align="left">Specifies the user name to use when connecting to a server that requires authentication.</td></tr><tr><td align="left"><strong>/?</strong></td><td align="left">Displays command syntax and options for the tool.</td></tr></tbody></table><p>例如:</p><pre><code>wsdl http://hostServer/WebserviceRoot/WebServiceName.asmx?WSDL--out:代表输出的文件名字wsdl /out:myProxyClass.cs http://hostServer/WebserviceRoot/WebServiceName.asmx?WSDL--language wsdl /language:VB /out:myProxyClass.vb http://hostServer/WebserviceRoot/WebServiceName.asmx?WSDL</code></pre><h3 id="什么是svcutil"><a href="#什么是svcutil" class="headerlink" title="什么是svcutil"></a>什么是svcutil</h3><p>​         The ServiceModel Metadata Utility tool is used to generate service model code from metadata documents, and metadata documents from service model code.</p><p>ServiceModel元数据实用工具用于从元数据文档生成服务模型代码，并从服务模型代码生成元数据文档。</p><p>参考地址:<a href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe?redirectedfrom=MSDN" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe?redirectedfrom=MSDN</a></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>1、 这两个工具的主要区别在于 wsdl.exe 工具与 ASMX 服务一起使用并且只生成代理代码；Svcutil.exe 工具与 WCF 服务一起使用，它可以在元数据和代码之间来回转换。</p><p>2、wsdl.exe 的默认行为是同时生成同步和异步方法，而 Svcutil.exe 工具仅在使用/async选项时才会生成异步方法。Svcutil.exe 工具还支持 WCF 中的新功能，例如 wsdl文件中可用于描述服务安全要求的策略部分.</p><p>3、在 wsdl.exe 和 Svcutil.exe 工具之间，只能使用 Svcutil.exe 工具来生成元数据</p><p>4、许多服务使用独立的 XML Schema (XSD) 文件来定义由其他服务共享的通用数据类型。这种方法非常常见，Wsdl.exe 和 Svcutil.exe 工具都可用于从 XML 架构生成适当的数据类型或数据协定。但是，Svcutil.exe 工具在用于 XSD 文件时会受到限制。具体来说，Svcutil.exe 工具只能从 XSD 文件生成数据协定，这意味着它不支持基于属性的架构。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学无止境。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>abpvnext自动注入</title>
      <link href="/2022/07/22/abpvnext-zi-dong-zhu-ru/"/>
      <url>/2022/07/22/abpvnext-zi-dong-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>​      我们在使用ABP vNext时，都知道该框架为我们实现了自动依赖注入(实现自动注入需要在项目里面创建Module类，并且将Module类上的DependsOn到相应的启动Module类或调用Module类，这步很关键)</p><h2 id="自动注入示例"><a href="#自动注入示例" class="headerlink" title="自动注入示例"></a>自动注入示例</h2><p>只要我们实现如下接口：<br>ITransientDependency 瞬时生命周期<br>ISingletonDependency 全局单例生命周期<br>IScopedDependency 作用域生命周期</p><p>如：</p><pre><code>pulic class Test:ITransientDependency {  // todo}</code></pre><h2 id="暗藏玄机"><a href="#暗藏玄机" class="headerlink" title="暗藏玄机"></a>暗藏玄机</h2><p>​        下面讲一下在真实的项目中遇到的“坑”,那就是在自动注入的时候系统会自动推断要注入的接口，并且是你实现的所有的接口他都会注入也不是放在第一个实现的接口才会注入，而是根据接口的名字来判断的，比如下面的类就会以接口IUserRepository注入：</p><pre><code>public class ReadOnlyBaseTemplateRepository:IReadOnlyBaseTemplateRepository,ISingletonDependency {}</code></pre><p>同理下面的类型也会以接口IUserRepository进行注入：</p><pre><code>public class EFCoreReadOnlyBaseTemplateRepository:IReadOnlyBaseTemplateRepository,ISingletonDependency {}</code></pre><p>但是下面这种情况就不能了：</p><pre><code>public class ReadOnlyEFCoreBaseTemplateRepository:IReadOnlyBaseTemplateRepository,ISingletonDependency {}</code></pre><p>提示的异常信息如下:</p><p>Autofac.Core.DependencyResolutionException: None of the constructors found with ‘Autofac.Core.Activators.Reflection.DefaultConstructorFinder’ on type ‘JGSoft.BaseTemplate.BaseTemplateAppService’ can be invoked with the available services and parameters:<br>Cannot resolve parameter ‘JGSoft.BaseTemplate.IReadOnlyBaseTemplateRepository _onlyBaseTemplateRepository’ of constructor ‘Void .ctor(JGSoft.BaseTemplate.IBaseTemplateRepository, Microsoft.Extensions.Localization.IStringLocalizer`1[JGSoft.Service.ModeObjectManagement.Localization.ModeObjectManagementResource], JGSoft.BaseTemplate.IReadOnlyBaseTemplateRepository)’.</p><p>一直告诉你没有注入。</p><p>然后查看了源码：</p><p>Volo.Abp.DependencyInjection.ExposeServicesAttribute.cs</p><pre><code>    private static List&lt;Type&gt; GetDefaultServices(Type type)    {        var serviceTypes = new List&lt;Type&gt;();        foreach (var interfaceType in type.GetTypeInfo().GetInterfaces())        {            var interfaceName = interfaceType.Name;            if (interfaceName.StartsWith(&quot;I&quot;))            {                interfaceName = interfaceName.Right(interfaceName.Length - 1);            }            if (type.Name.EndsWith(interfaceName))            {                serviceTypes.Add(interfaceType);            }        }        return serviceTypes;    }</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>能看出，推断方法是去掉接口名的“I”之后【interfaceName.Right(interfaceName.Length - 1)】看这个类名是否是【type.Name.EndsWith(interfaceName)】这个字符串结尾，如果是则注入，如果不是则不注入，并且将会递归他所有实现的接口，如果有多个接口都满足条件，则将会以这些接口进行注入。<br>还有一点就是实现了这三个自动依赖注入的接口的类型的，都将会以自身类型注入到容器</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript学习章节</title>
      <link href="/2022/07/14/typescript-xue-xi-zhang-jie/"/>
      <url>/2022/07/14/typescript-xue-xi-zhang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-什么是TypeScript"><a href="#第一章-什么是TypeScript" class="headerlink" title="第一章:什么是TypeScript"></a>第一章:什么是TypeScript</h2><p>​          TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准,TypeScript 由微软开发的自由和开源的编程语言,TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上.</p><p>JavaScript和TypeScript的区别</p><p>​       TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译,TypeScript是面向对象编程。</p><p>如图：可以看出他们之间的关系</p><p><img src="https://lszai90.github.io/images/ts/TypeScript1.png" alt="TypeScript1.png"></p><p><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">https://www.typescriptlang.org/</a></p><h2 id="第二章-安装及编译"><a href="#第二章-安装及编译" class="headerlink" title="第二章:安装及编译"></a>第二章:安装及编译</h2><h3 id="1、通过几种安装方式"><a href="#1、通过几种安装方式" class="headerlink" title="1、通过几种安装方式"></a>1、通过几种安装方式</h3><pre><code>第一种:npm install -g typescript   --需要安装nodejs第二种:cnpm install -g typescript  --如果使用cnpm 请先装 cnpm第三种:yarn global add typescript  --如果使用yarn 请先装 yarn</code></pre><p>typescript 安装完成后、在运行Cmd输入命名：</p><pre><code>tsc -v</code></pre><p>出现此图中的就代表已经安装好</p><p><img src="https://lszai90.github.io/images/ts/TypeScript2.png" alt="TypeScript1.png"></p><h3 id="2、编译ts-文件"><a href="#2、编译ts-文件" class="headerlink" title="2、编译ts 文件"></a>2、编译ts 文件</h3><p>在VsCode 里面建立建立一个A001.ts文件输入:</p><pre><code>console.log(&#39;你好、ts&#39;);</code></pre><p>然后在终端下输入:</p><pre><code>tsc A001.ts</code></pre><p>编译出来的文件如图：</p><p><img src="https://lszai90.github.io/images/ts/TypeScript3.png" alt="TypeScript1.png"></p><h3 id="3、TypeScript开发工具VSCode-自动编译-ts文件"><a href="#3、TypeScript开发工具VSCode-自动编译-ts文件" class="headerlink" title="3、TypeScript开发工具VSCode 自动编译.ts文件"></a>3、TypeScript开发工具VSCode 自动编译.ts文件</h3><h4 id="3-1-创建tsconfig-json文件-执行-tsc-–init-生成配置文件"><a href="#3-1-创建tsconfig-json文件-执行-tsc-–init-生成配置文件" class="headerlink" title="3.1 创建tsconfig.json文件  执行 tsc –init 生成配置文件"></a>3.1 创建tsconfig.json文件  执行 tsc –init 生成配置文件</h4><p>​       在文件tsconfig.json中</p><pre><code> &quot;outDir&quot;: &quot;./js&quot;,    代表自动编译.ts文件 输出在js 文件下</code></pre><h4 id="3-2-自动监视配置-保存自动编译"><a href="#3-2-自动监视配置-保存自动编译" class="headerlink" title="3.2  自动监视配置(保存自动编译)"></a>3.2  自动监视配置(保存自动编译)</h4><p>​        在点击【终端】—&gt;运行任务—&gt;typescript–&gt;tsc监视</p><h2 id="第三章-TypeScript中的数据类型"><a href="#第三章-TypeScript中的数据类型" class="headerlink" title="第三章:TypeScript中的数据类型"></a>第三章:TypeScript中的数据类型</h2><p>typescript 中为了使编写的代码更加规范,更有利于维护，增加了类型效验，在typescript 中主要有以下数据类型</p><p>布尔类型: boolean</p><p>数字类型:number</p><p>字符串类型:string</p><p>数组类型：array</p><p>元组类型：tuple</p><p>枚举类型：enum</p><p>任意类型：any</p><p>null  表示对象值缺失 和undefined 用于初始化变量为一个未定义的值</p><p>void :用于标识方法返回值的类型，表示该方法没有返回值</p><p>never: 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值</p><h4 id="布尔类型-boolean-true-false"><a href="#布尔类型-boolean-true-false" class="headerlink" title="布尔类型: boolean    true  false"></a>布尔类型: boolean    true  false</h4><pre><code>var flag:boolean=true;</code></pre><h4 id="数字类型-number"><a href="#数字类型-number" class="headerlink" title="数字类型:number"></a>数字类型:number</h4><pre><code>var  a:number=123;</code></pre><h4 id="字符串类型-string"><a href="#字符串类型-string" class="headerlink" title="字符串类型:string"></a>字符串类型:string</h4><pre><code>var a1:string=&quot;ls&quot;;</code></pre><h4 id="数组类型：array"><a href="#数组类型：array" class="headerlink" title="数组类型：array"></a>数组类型：array</h4><pre><code>第一种定义数组的方式:数字类型数组var  arry:number[]=[1,2,3,4]字符类型数组var  arry1:string[]=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]第二种定义:var arry:Array&lt;number&gt;=[1,2,3,4]var arry1:Array&lt;string&gt;=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]</code></pre><h4 id="元组类型：tuple"><a href="#元组类型：tuple" class="headerlink" title="元组类型：tuple"></a>元组类型：tuple</h4><p>元组类型属于数组的一种,元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同</p><pre><code>var arry2:[string,number]=[&quot;ls&quot;,12]</code></pre><h4 id="枚举类型：enum"><a href="#枚举类型：enum" class="headerlink" title="枚举类型：enum"></a>枚举类型：enum</h4><p>如果不给=10 等，默认从0开始</p><pre><code>enum  fromtype{   &quot;表单&quot;=10,   &quot;列表&quot;=20,   &quot;A&quot;=30}let  cc:fromtype=fromtype.A;//打印对应数值console.log(cc);也可以直接获取console.log(fromtype.A);</code></pre><h4 id="任意类型：any"><a href="#任意类型：any" class="headerlink" title="任意类型：any"></a>任意类型：any</h4><p>在编程过程中尽量不要用any.  只有当编程时类型不明确时才用。</p><pre><code>var  a:any=&quot;1212&quot;;var  a:any=1;var  a:any=true;</code></pre><h4 id="null-和undefined"><a href="#null-和undefined" class="headerlink" title="null  和undefined"></a>null  和undefined</h4><pre><code>let num: number;//num = 1; // 编译正确//num = undefined;    // 编译错误//num = null;    // 编译错误let num:number|null|undefined;//num = 1; // 编译正确//num = undefined;    // 编译正确//num = null;    // 编译正确</code></pre><p>当我们定义变量时 如我们 这样定义 let num: number;  没有给他具体赋值 、那么我们在使用的时候就会报错。为了避免这种情况我们就 let num:number|null</p><p>这样定义 如果没有赋值 我们直接使用num 那么他的值 就是null</p><h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p>用于标识方法返回值的类型，表示该方法没有返回值</p><pre><code>//void  不需要返回function Sum():void{    console.log(&#39;ddd&#39;);}//如果需要返回function Sum1():Number{    return 1;}</code></pre><h4 id="never"><a href="#never" class="headerlink" title="never"></a>never</h4><p>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环），示例代码如下：</p><pre><code>let num:never;let num1:number;//第一 其他类型的不能给never类型赋值num=123;//错误  消息提示:不能将类型“number”分配给类型“never”。//第二 never 赋值给nevernum=(()=&gt;{throw new Error(&#39;execption&#39;)})();//正确//第三 never 类型也可以赋值给其他类型num1=(()=&gt;{throw new Error(&#39;execption&#39;)})();//正确</code></pre><h2 id="第四章：函数"><a href="#第四章：函数" class="headerlink" title="第四章：函数"></a>第四章：函数</h2><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>//ES5 定义函数方式</p><pre><code>//第一种函数声明法function Run(){  console.log(&#39;ddd&#39;);}//第二种匿名函数var Run1=function(){    console.log(&#39;ddd&#39;);}</code></pre><p>//TS 定义函数方式‘</p><pre><code>//第一种 函数声明法function run():string{   return  &#39;A&#39;;}//第二种 匿名函数var getinfo=function():string{    return &#39;B&#39;;}//第一种 函数声明法 传入参数function run(username:string):string{    return  username;}//第二种 匿名函数var getuserinfo=function(username:string,age:number):string{    return `${username}----${age}`;}</code></pre><p>最大的区别：就是传入和返回 全部需要定义类型、更好的编程规范。如果我们不需要返回参数那么我们也可以这样写:</p><pre><code>function run():void{    console.log(&#39;ddd&#39;);}</code></pre><h4 id="可选参数："><a href="#可选参数：" class="headerlink" title="可选参数："></a>可选参数：</h4><pre><code>var getuserinfo=function(username:string,age?:number):string{    return `${username}----${age}`;}alert(getuserinfo(&#39;liu&#39;,10));alert(getuserinfo(&#39;liu&#39;));--age 可以不传</code></pre><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><pre><code>var getuserinfo=function(username:string,age:number=10):string{    return `${username}----${age}`;}alert(getuserinfo(&#39;liu&#39;));--age 如果不传入 那么age 默认就是10,这个跟.Net 编程一样</code></pre><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p> 有一种情况，我们不知道要向函数传入多少个参数，这时候我们就可以使用剩余参数来定义。剩余参数语法允许我们将一个不确定数量的参数作为一个数组传入.</p><pre><code>//像这样如果我们后面还有很多的参数，那么我们就需要在function的入口参数写很多var getUserInfo=function(A:number,B:number,C:number,D:number):number{    return A+B+C+D;}//在TS中有一个叫【剩余参数】那么我们可以简写var getNumberInfo=function(...result:number[]):number{    var SumValue:number=0;    for(var i=0;result.length;i++){        SumValue+=result[i];    }    return SumValue;}//还有一种写法  A=1 B=2 后面的参数都用剩余参数表示var getNumberInfo=function(A:number,B:number,...result:number[]):number{    var SumValue:number=A+B;    for(var i=0;result.length;i++){        SumValue+=result[i];    }    return SumValue;}alert(getNumberInfo(1,2,3,4,5,6,7,8))</code></pre><h4 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h4><p>ES5中函数重载：</p><pre><code>//ES5 中函数方法名相同 后面一个会替换掉上一个 如:function run(A){}function run(A,B){}</code></pre><p>TS 函数的重载</p><pre><code>//TS 类型不一样的重载function run(A:string):string;function run(A:number):string;function run(A:any):any{    if(typeof A===&#39;string&#39;){          return `我的名字叫做:${A}`;    }else{        return `我的年龄叫做:${A}`;    }}//TS 参数不一样的重载function run(Name:string):string;function run(Name:string,age:number):string;function run(Name:any,age?:any):any{    if(age){       return `我的名字:${Name}年龄:${age}`;    }else{        return `我的名字:${Name}`;    }}alert(run(&#39;lius&#39;,20));//不会报错alert(run(&#39;lius&#39;));//不会报错</code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数也叫Lambda 函数，箭头函数this 指向问题、箭头函数里面的this 指向上下文</p><pre><code>//ES5 写法setTimeout(function(){    console.log(&#39;runing&#39;);}, 1000);//ES6 写法setTimeout(() =&gt; {    console.log(&#39;runing&#39;);}, 1000);</code></pre><h2 id="第五章：类"><a href="#第五章：类" class="headerlink" title="第五章：类"></a>第五章：类</h2><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="ES5中的继承"><a href="#ES5中的继承" class="headerlink" title="ES5中的继承"></a>ES5中的继承</h5><pre><code>//类//ES5 中的类function Person(){  this.Name=&#39;lius&#39;;  this.Age=&#39;30&#39;;  this.Run=function(){    alert(`${this.Name}在跑步`);  }}//静态方法Person.Print=function(){    alert(&#39;正在打印&#39;);}//原型链Person.prototype.Sex=&#39;男&#39;;//在原型链上添加属性Person.prototype.Worker=function(){    alert(`${this.Name}在工作`);}//静态方法不需要实例化Person.Print();//我们调用时var p=new Person();alert(p.Name);alert(p.Run());alert(p.Worker());//ES5中的集成 分为2种//第一种:构造函数的继承function Web(){    Person.call(this);//继承}var w=new Web();alert(w.Name);alert(w.Run());alert(w.Worker());// 构造函数继承 对于原型链上的方法和属性都调用不了//第二种:原型链的继承var  w=new Web(){}w.prototype=new Person();//原型链的继承 alert(w.Name);alert(w.Run());alert(w.Worker()); //都可以调用的到</code></pre><p> ES5 继承 总结有以下几点</p><p>第一:原型链和构造函数有什么区别</p><p>  原型链上的属性可以被多个实例共享，构造函数不会</p><p>第二:原型链的继承和构造函数继承有什么区别</p><p>  原型链的继承:可以调用、类本身的属性和方法还有原型链上扩展的方法和属性。</p><p>  构造函数的继承:只能调用、类本身的属性和方法。</p><p>第三:静态方法申明</p><p>  静态方法不需要实例化</p><p>  Person.Print();</p><h5 id="TS中的继承"><a href="#TS中的继承" class="headerlink" title="TS中的继承"></a>TS中的继承</h5><pre><code>TS 中类的定义:class Person{   public name:string;   public age:number;    constructor(name:string,age:number){        this.name=name;        this.age=age;    }    run(){        return `${this.name} 正在跑步`;    }    getAge(){        return `${this.name} 年龄是:${this.age}`;    }    setAge(age?:number){        if(age){          return `${this.name} 年龄是:${age}`;        }else{            return `${this.name} 年龄是:${this.age}`;        }    }}var P=new Person(&#39;lius&#39;,20);alert(P.run());//lius正在跑步alert(P.setAge(18));//lius年龄是 18alert(P.getAge());//lius年龄是 18alert(P.setAge());//lius年龄是 20TS 中的继承 关键字  extends  superclass Person{    name:string;    age:number;    constructor(name:string,age:number){        this.name=name;        this.age=age;    }    run(){        return `${this.name} 正在跑步`;    } } //继承 extends  superclass Web extends Person{   constructor(name:string,age:number){     super(name,age)   }}var w=new Web(&#39;liuss&#39;,18);w.run();// liuss 正在跑步</code></pre><p>总结：</p><p>第一: TS继承用到的关键字 extends    super</p><p>第二：儿子拥有父亲的一切属性</p><p>第三：儿子可以用除父亲以外 自定义属性及事件</p><h4 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h4><p>public:  //公有   可以在任何地方被访问</p><p>private: //私有   私有，只能被其定义所在的类访问。</p><p>protected://受保护，可以被其自身以及其子类访问</p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><pre><code>class Person{  public  name:string;  public age:number;    constructor(name:string,age:number){        this.name=name;        this.age=age;    }    run(){        return `${this.name} 正在跑步`;    } } //继承 extends  superclass Web extends Person{   constructor(name:string,age:number){     super(name,age)   }   // 第一 直接 重载 不需要父类的任何东西  //run() {  //return `${this.name} 正在跑步-Two`;  //}  //第二  如果重载之后 还需要调用父类的方法 那么  run() {    //可以先执行重载后的东西  在执行父类方法    return super.run();  }}var w=new Web(&#39;liuss&#39;,18);w.run();// liuss 正在跑步 正在跑步-Two</code></pre><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><pre><code>class Person { public name: string; public age: number;  constructor(name: string, age: number) {    this.name = name;    this.age = age;  }  static run() {    return `正在跑步`;  }}alert(Person.run())</code></pre><p>总结：静态关键字【static】静态成员可以直接通过类名调用.</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>父类定义一个方法，让子类去实现、每个子类有不同的表现。</p><pre><code>//动物类class Animal {  public name: string;  constructor(name: string) {    this.name = name;  }  eat() {}}class dog extends Animal {  constructor(name: string) {    super(name);  }  eat(): void {    alert(`${this.name}在吃肉`);  }}class Cat extends Animal {  constructor(name: string) {    super(name);  }  eat(): void {    alert(`${this.name}吃耗子`);  }}</code></pre><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>typescript  抽象类，它是提供其他类继承的基类，不能直接被实例化。</p><p>用abstract 关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体的实现必须在派生类中实现。</p><p>abstract 关键字只能放在抽象类里面。</p><p>抽象类和抽象方法用来定义标准。</p><pre><code>//抽象 动物类abstract class Animal {  public name: string;  constructor(name: string) {    this.name = name;  }  abstract eat(): string;}//小狗class Dog extends Animal {  constructor(name: string) {    super(name);  }  eat(): string {    return `${this.name} 在吃东西`;  }}class Cat extends Animal {  constructor(name: string) {    super(name);  }  eat(): string {    return `${this.name} 在吃🐟`;  }}</code></pre><h2 id="第六章-接口"><a href="#第六章-接口" class="headerlink" title="第六章 接口"></a>第六章 接口</h2><h4 id="属性接口"><a href="#属性接口" class="headerlink" title="属性接口:"></a>属性接口:</h4><pre><code>function Run(name: string): void {  console.log(&quot;&quot;);}Run(&quot;dddd&quot;);</code></pre><h4 id="对象接口"><a href="#对象接口" class="headerlink" title="对象接口"></a>对象接口</h4><p>接口行为和方法的规范 对批量方法进行约束</p><pre><code>interface DtoInput {  fristname: string;  age?: number;}// 对象约束function RunTwo(dto: DtoInput) {  if (dto) {    console.log(`${dto.fristname}`);  }}//调用RunTwo({ fristname: &quot;ls&quot; }); //正确 因为age 是不必填写RunTwo({ fristname: &quot;ls&quot;, age: 12 });</code></pre><p>对象 可选属性【?】</p><pre><code>//接口  可选属性【?】interface DtoInput {  fristname: string;  age?: number;}</code></pre><pre><code>//调用方法interface config {  type: string;  data: string;  url: string;  dataType: string;}function ajax(config: config) {  var xhr = new XMLHttpRequest();  //打开链接  xhr.open(config.type, config.url, true);  xhr.send(config.data); //发送数据  xhr.onreadystatechange = function () {    if (xhr.status == 200 &amp;&amp; xhr.readyState == 4) {      if ((config.dataType = &quot;json&quot;)) {        JSON.parse(xhr.responseText);      } else {        xhr.responseText;      }    }  };}ajax({  type: &quot;get&quot;,  data: &quot;username=ls&quot;,  url: &quot;https://baidu.com&quot;,  dataType: &quot;json&quot;,});</code></pre><h4 id="原生JS-封装的接口"><a href="#原生JS-封装的接口" class="headerlink" title="原生JS 封装的接口"></a>原生JS 封装的接口</h4><pre><code>//调用方法interface config {  type: string;  data: string;  url: string;  dataType: string;}function ajax(config: config) {  var xhr = new XMLHttpRequest();  //打开链接  xhr.open(config.type, config.url, true);  xhr.send(config.data); //发送数据  xhr.onreadystatechange = function () {    if (xhr.status == 200 &amp;&amp; xhr.readyState == 4) {      if ((config.dataType = &quot;json&quot;)) {        JSON.parse(xhr.responseText);      } else {        xhr.responseText;      }    }  };}ajax({  type: &quot;get&quot;,  data: &quot;username=ls&quot;,  url: &quot;https://baidu.com&quot;,  dataType: &quot;json&quot;,});</code></pre><h4 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h4><p>函数类型接口对输入 输出进行约束   还可以进行批量约束</p><pre><code>//函数类型接口对输入 输出进行约束interface One {  (key: string, value: string): string;}var one1: One = function (key: string, value: string): string {  return key + &quot;_&quot; + value;};</code></pre><h4 id="可索引接口"><a href="#可索引接口" class="headerlink" title="可索引接口"></a>可索引接口</h4><p>数据 对象的约束 (不常用)</p><pre><code>interface UserArr {  [index: number]: string;}var aa: UserArr = [&quot;2&quot;, &quot;3&quot;];console.log(aa[0]);</code></pre><h4 id="类类型接口"><a href="#类类型接口" class="headerlink" title="类类型接口"></a>类类型接口</h4><p>关键字:implements  实现</p><pre><code>interface Anli {  name: string;  eat(str: string): void;}//implements  实现接口  class dog implements Anli {  name: string;  constructor(name: string) {    this.name = name;  }  eat(): void {    console.log(this.name + &quot;吃食物&quot;);  }}var dogs=new dog(&#39;kk&#39;);dogs.eat();</code></pre><h4 id="接口扩展"><a href="#接口扩展" class="headerlink" title="接口扩展"></a>接口扩展</h4><pre><code>//动物接口interface Anli {  eat(): void;}//人的也是动物interface People extends Anli {  work(): void;}//具体的人名class XM implements People {  public name: string;  constructor(name: string) {    this.name = name;  }  eat(): void {    console.log(&quot;dd&quot;);  }  work(): void {    console.log(&quot;aa&quot;);  }}复杂实现   extends 类 里面必须用Supper()  在进行 implements 实现class DoSomethings {  public name: string;  constructor(name: string) {    this.name = name;  }  //做具体事情  codeing() {    console.log(this.name + &quot;学习tsCode&quot;);  }}//首先我们继承DoSomethins 然后再实现我们的接口class XMExt extends DoSomethings implements People {  constructor(name: string) {    super(name);  }  eat(): void {    console.log(&quot;1&quot;);  }  work(): void {    console.log(&quot;2&quot;);  }}var dd=new XMExt(&#39;lius&#39;);dd.codeing();dd.eat();dd.work();</code></pre><h2 id="第七章-泛型"><a href="#第七章-泛型" class="headerlink" title="第七章  泛型"></a>第七章  泛型</h2><h4 id="泛型的定义"><a href="#泛型的定义" class="headerlink" title="泛型的定义"></a>泛型的定义</h4><p>可以支持任意类型</p><pre><code>//泛型  具体是什么类型是前端调用的时候 决定【传入的类型和返回的类型必须一致】function GetData&lt;T&gt;(value: T): T {  return value;}</code></pre><p>泛型函数</p><pre><code>//泛型类//1、比如我有一个最小堆的算法class Progam {  private list: number[] = [];  add(val: number) {    this.list.push(val);  }  //求最新数  min(): number {    var num = this.list[0];    for (let index = 0; index &lt; this.list.length; index++) {      if (num &gt; this.list[index]) {        num = this.list[index];      }    }    return num;  }}var p = new Progam();p.add(2);p.add(1);//最小数p.min();//2、需要同时支持返回数字和字符串两种类型 通过泛型来实现//需要同时支持返回数字和字符串两种类型class ProgamOne&lt;T&gt; {  public list: T[] = [];  add(num: T) {    this.list.push(num);  }  min(): T {    var num = this.list[0];    for (let index = 0; index &lt; this.list.length; index++) {      if (num &gt; this.list[index]) {        num = this.list[index];      }    }    return num;  }}var pone = new ProgamOne&lt;number&gt;();pone.add(2);pone.add(1);//最小数pone.min();var ptwo = new ProgamOne&lt;string&gt;();ptwo.add(&quot;2&quot;);ptwo.add(&quot;1&quot;);//最小数ptwo.min();</code></pre><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><pre><code>class ProgamOne&lt;T&gt; {  public list: T[] = [];  add(num: T) {    this.list.push(num);  }  min(): T {    var num = this.list[0];    for (let index = 0; index &lt; this.list.length; index++) {      if (num &gt; this.list[index]) {        num = this.list[index];      }    }    return num;  }}var pone = new ProgamOne&lt;number&gt;();pone.add(2);pone.add(1);//最小数pone.min();var ptwo = new ProgamOne&lt;string&gt;();ptwo.add(&quot;2&quot;);ptwo.add(&quot;1&quot;);//最小数ptwo.min();</code></pre><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><pre><code>回顾一下函数接口interface confingInterface {  (value1: string, value2: string): string;}var One: confingInterface = function (value1: string, value2: string): string {  return value1 + value2;};One(&quot;1&quot;, &quot;2&quot;);2种定义泛型接口第一种：interface confingInterfaceOne {  &lt;T&gt;(value1: T): T;}var Two: confingInterfaceOne = function &lt;T&gt;(value1: T): T {  return value1;};Two&lt;string&gt;(&quot;ddd&quot;);第二种:interface confingInterfaceTwo&lt;T&gt; {  (value1: T): T;}var GetData = function &lt;T&gt;(value1: T): T {  return value1;};var MyGetData:confingInterfaceTwo&lt;string&gt;=GetData;MyGetData(&quot;344&quot;);</code></pre><pre><code>class User {  username: string | undefined;  passsword: string | undefined;}class User2 {  username: string | undefined;  passsword: string | undefined;}class DbHelper&lt;T&gt; {  add(user: T): boolean {    console.log(user);    return true;  }}var users = new User();users.username = &quot;d&quot;;users.passsword = &quot;t&quot;;//var usersS = new User2();//usersS.username = &quot;d&quot;;//usersS.passsword = &quot;t&quot;;var ddd = new DbHelper();ddd.add(users);</code></pre><h2 id="第八章-模块"><a href="#第八章-模块" class="headerlink" title="第八章 模块"></a>第八章 模块</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>TypeScript 模块的设计理念是可以更换的组织代码。</p><p>模块是在其自身的作用域里执行，并不是在全局作用域，这意味着定义在模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 <strong>export</strong> 导出它们。类似地，我们必须通过 <strong>import</strong> 导入其他模块导出的变量、函数、类等。</p><p>两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。</p><p>模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的JavaScript模块加载器是服务于 Node.js 的 CommonJS 和服务于 Web 应用的 Require.js。</p><p>此外还有有 SystemJs 和 Webpack。</p><h4 id="简单的模块【Demo】"><a href="#简单的模块【Demo】" class="headerlink" title="简单的模块【Demo】"></a>简单的模块【Demo】</h4><pre><code>简单的模块 暴露及导入db.ts 文件var dbconn = &quot;dddd&quot;;//export 暴露方法export function getdata(): any[] {  console.log(&quot;dddd&quot;);  return [    {      Lname: &quot;lius&quot;,    },  ];}export function savedata(): boolean {  console.log(&quot;dddd&quot;);  return true;}A001.ts 导入import { getdata,savedata } from &quot;./modules/db&quot;;getdata();savedata();如果我们模块中方法很多我们可以在这样写：var dbconn = &quot;dddd&quot;;//export 暴露方法function getdata(): any[] {  console.log(&quot;dddd&quot;);  return [    {      Lname: &quot;lius&quot;,    },  ];}function savedata(): boolean {  console.log(&quot;dddd&quot;);  return true;}export { dbconn, getdata, savedata };还有一种导出方式: export default 函数或者方法等</code></pre><p>总结:</p><p>暴露模块中的方法有3种：</p><p>第一种： 每个属性前面加： export  getdata</p><p>第二种:    在模块底部写： export {  getdata }   当我们暴露的方法很多的时候可以直接写在{ }对象中</p><p>第三种:  默认导出方式：export default  getdata</p><p>注意：export   在模块中可以出现多次、export default  一个模块中只能出现一次。</p><p>export  getdate  暴露时 我们导入的 时候 写法：import { getdata } from “./modules/db”; 应该用{} 包裹起来</p><p>export default  getdate   暴露时 我们导入的 时候 写法 import getdata from “./modules/db”;  不用{}包裹起来</p><h2 id="第九章-TypeScript-命名空间"><a href="#第九章-TypeScript-命名空间" class="headerlink" title="第九章:TypeScript 命名空间"></a>第九章:TypeScript 命名空间</h2><p>命名空间一个最明确的目的就是解决重名问题。</p><p>假设这样一种情况，当一个班上有两个名叫小明的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的姓（王小明，李小明），或者他们父母的名字等等。</p><p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的。这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p><h4 id="命名空间语法"><a href="#命名空间语法" class="headerlink" title="命名空间语法"></a>命名空间语法</h4><pre><code>namespace A{  var dbconn = &quot;dddd&quot;;  //export 暴露方法 export function getdata(): any[] {    console.log(&quot;dddd&quot;);    return [      {        Lname: &quot;lius&quot;,      },    ];  }  export function savedata(): boolean {    console.log(&quot;dddd&quot;);    return true;  }  //export { dbconn, getdata, savedata };  //默认导出只能在 ECMAScript-style 模块中使用  //export default getdata;}</code></pre><p>可以直接把命名空间进行暴露出</p><pre><code>export namespace A{  var dbconn = &quot;dddd&quot;;  //export 暴露方法 export function getdata(): any[] {    console.log(&quot;dddd&quot;);    return [      {        Lname: &quot;lius&quot;,      },    ];  }  export function savedata(): boolean {    console.log(&quot;dddd&quot;);    return true;  }  //export { dbconn, getdata, savedata };  //默认导出只能在 ECMAScript-style 模块中使用  //export default getdata;}</code></pre><p>还可以这样引用</p><pre><code>// In a .d.ts file or .ts file that is not a module:/// &lt;reference path=&quot;myModules.d.ts&quot; /&gt;相当于就是import * as m from &quot;SomeModule&quot;;</code></pre><h2 id="第十章-TypeScript装饰器"><a href="#第十章-TypeScript装饰器" class="headerlink" title="第十章:TypeScript装饰器"></a>第十章:TypeScript装饰器</h2><p>在不修改原类的情况下、进行类的属性、方法扩展。</p><h4 id="普通的装饰器"><a href="#普通的装饰器" class="headerlink" title="普通的装饰器"></a>普通的装饰器</h4><pre><code>//装饰器function logClass(Pararms: any) {  //这个就是代表的是HttpClient的类  Pararms.prototype.apiUrl = &quot;apiaddress&quot;;  Pararms.prototype.run = function () {    console.log(&quot;我正在跑步&quot;);  };}@logClassclass HttpClient {  constructor() {}  getUser() {}}//调用一下；var hp: any = new HttpClient();console.log(hp.apiUrl);hp.run();</code></pre><p>注意一点就是必须在tsconfig中配置一下：”experimentalDecorators”: true,   不然会有警告信息</p><p>Experimental support for decorators is a feature that is subject to change in a future release. Set the ‘experimentalDecorators’ option in your ‘tsconfig’ or ‘jsconfig’ to remove this warning</p><h4 id="工厂装饰器"><a href="#工厂装饰器" class="headerlink" title="工厂装饰器"></a>工厂装饰器</h4><pre><code>function logClassA(Pararms: string) { //返回function 就是代表的【HttpClientA】  return function (target: any) {    console.log(Pararms);    //console.log(target);    target.prototype.apiUrl=Pararms;  };}@logClassA(&quot;http://api&quot;)class HttpClientA {  constructor() {}  getUserInfo() {}}var   hpa:any=new HttpClientA();console.log(hpa.apiUrl)</code></pre><p>这里就是给装式器传入参数。</p><h4 id="类装式器"><a href="#类装式器" class="headerlink" title="类装式器"></a>类装式器</h4><p>修改原有类的构造函数及方法</p><pre><code>function logClass(target: any) {  console.log(target);  //返回类 继承于Target  return class extends target {    apiUrl = &quot;重载后的ApiUrl&quot;;    getUserInfo() {      console.log(this.apiUrl + &quot;---&quot;);    }  };}@logClassclass HttpClient {  public apiUrl: string | undefined;  constructor() {    this.apiUrl = &quot;我是之前的apiUrl&quot;;  }  getUserInfo() {    console.log(this.apiUrl);  }}var httpa: any = new HttpClient();httpa.getUserInfo();</code></pre><h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><pre><code>//属性装饰器function logProperty(Params:any){   return function(target:any,Params:any){      console.log(target);      console.log(Params);      target[Params]=&#39;apiaddressto&#39;;   }}class HttpClient {  @logProperty(&#39;http://baidu.com&#39;)  public apiUrl: string | undefined;  constructor() {  }  getUserInfo() {   console.log(this.apiUrl);  }}var HttpC=new HttpClient();HttpC.getUserInfo();</code></pre><h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><p>3个参数</p><p>1、如果是静态对象 获取的是构造函数,如果是类 则获取的是类的原型</p><p>2、Params 获取方法成员</p><p>3、Val 成员的属性描述符</p><pre><code>//方法装饰器function logMethod(Params: any) {  return function (target: any, Params: any,Val:any) {    console.log(target);    console.log(Params);    console.log(Val.value);  };}class HttpClient {  public apiUrl: string | undefined;  constructor() {}  @logMethod(&quot;http://ddd&quot;)  getUserInfo() {    console.log(&quot;AAAAAA&quot;);  }}var HttpC = new HttpClient();HttpC.getUserInfo();输出是这样：target:{constructor: ƒ, getUserInfo: ƒ}constructor: class HttpClientgetUserInfo: ƒ getUserInfo()[[Prototype]]: ObjectgetUserInfogetUserInfo() {        console.log(&quot;AAAAAA&quot;);    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>httpClient忽略SSL</title>
      <link href="/2022/07/13/httpclient-hu-lue-ssl/"/>
      <url>/2022/07/13/httpclient-hu-lue-ssl/</url>
      
        <content type="html"><![CDATA[<p>是今天遇到HttpClient 请求时、客户提供的域名证书有问题；</p><p>如图:</p><p><img src="https://lszai90.github.io/images/httpClient/httpClient01.png" alt></p><p>解决办法:</p><p>在httpClient 请求前 加上此代码,完美解决。</p><pre><code>ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) =&gt; true;ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nvm</title>
      <link href="/2022/07/11/nvm/"/>
      <url>/2022/07/11/nvm/</url>
      
        <content type="html"><![CDATA[<h3 id="nvm-介绍及优点"><a href="#nvm-介绍及优点" class="headerlink" title="nvm 介绍及优点"></a>nvm 介绍及优点</h3><p>nvm的全称是 Node Version Manager，Node.js 版本管理器</p><p>使用它的好处有三点:<br>第一:nvm是命令行安装，有专业范，而且非常方便。尤其是在无图形界面的服务器上安装，命令行就显得更方便了。<br>第二:nvm中可以列出所有 Nodejs版本，让我们既可以选择安装最新版，也可以选择安装稍微稳定一些的LTS版本。<br>第三:nvm还可以同时安装多个 Nodejs版本，并在各个版本之间来回切换。</p><p>总之，nvm安装是目前专业前端开发者最常见的安装 Node.js的方式</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><pre><code>https://github.com/coreybutler/nvm-windows/releases</code></pre><p><img src="https://lszai90.github.io/images/nvm/nvm01.png" alt></p><h3 id="查看是否安装好"><a href="#查看是否安装好" class="headerlink" title="查看是否安装好"></a>查看是否安装好</h3><pre><code> nvm v</code></pre><p>出现如下图:<br><img src="https://lszai90.github.io/images/nvm/nvm02.png" alt></p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>–基本命名<br>nvm install latest –安装最后一个版本<br>nvm install 16.3.2 –安装指定版本<br>nvm list           –查看安装了哪些版本的node.js<br>nvm use 16.3.2     –切换版本<br>nvm uninstall 16.3.2 –卸载哪个版本</p><h3 id="常用命名"><a href="#常用命名" class="headerlink" title="常用命名"></a>常用命名</h3><p>nvm arch ：显示node是运行在32位还是64位。<br>nvm install <version> [arch] ：安装node， version是特定版本也可以是最新稳定版本latest。可选参数arch指定安装32位还是64位版本，默认是系统位数。可以添加–insecure绕过远程服务器的SSL。<br>nvm list [available] ：显示已安装的列表。可选参数available，显示可安装的所有版本。list可简化为ls。<br>nvm on ：开启node.js版本管理。<br>nvm off ：关闭node.js版本管理。<br>nvm proxy [url] ：设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。<br>nvm node_mirror [url] ：设置node镜像。默认是<a href="https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。" target="_blank" rel="noopener">https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。</a><br>nvm npm_mirror [url] ：设置npm镜像。<a href="https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。" target="_blank" rel="noopener">https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。</a><br>nvm uninstall <version> ：卸载指定版本node。<br>nvm use [version] [arch] ：使用制定版本node。可指定32/64位。<br>nvm root [path] ：设置存储不同版本node的目录。如果未设置，默认使用当前目录。<br>nvm version ：显示nvm版本。version可简化为v。</version></version></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>V2和V3区别</title>
      <link href="/2022/07/11/v2-he-v3-qu-bie/"/>
      <url>/2022/07/11/v2-he-v3-qu-bie/</url>
      
        <content type="html"><![CDATA[<h3 id="1、Vue2和Vue3双向数据绑定原理发⽣了改变"><a href="#1、Vue2和Vue3双向数据绑定原理发⽣了改变" class="headerlink" title="1、Vue2和Vue3双向数据绑定原理发⽣了改变"></a>1、Vue2和Vue3双向数据绑定原理发⽣了改变</h3><p>​      Vue2 的双向数据绑定是利⽤ES5 的⼀个 API Object.definePropert()对数据进⾏劫持 结合 发布订阅模式的⽅式来实现的。<br>​      Vue3 中使⽤了 es6 的 ProxyAPI 对数据代理。<br>​      相⽐于vue2.x，使⽤proxy的优势如下<br>​      defineProperty只能监听某个属性，不能对全对象监听<br>​      可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）<br>​      可以监听数组，不⽤再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化</p><h3 id="2、生命周期"><a href="#2、生命周期" class="headerlink" title="2、生命周期"></a>2、生命周期</h3><p>LifeCycle(Hooks) 3.0当中的⽣命周期与2.0的⽣命周期出现了很⼤的不同：<br>beforeCreate -&gt; 请使⽤ setup() 创建时<br>created -&gt; 请使⽤ setup() 创建时</p><p>beforeMount -&gt; onBeforeMount  当这个钩子被调用时，组件已经完成了它的反应状态的设置，但是还没有创建 DOM 节点。它即将第一次执行它的 DOM 渲染效果在服务器端渲染期间不会调用此挂钩。</p><p>mounted -&gt; onMounted  组件在以下情况下被视为已挂载：<br>它的所有同步子组件都已挂载（不包括异步组件或<suspense>树内的组件）。<br>它自己的 DOM 树已创建并插入到父容器中。请注意，如果应用程序的根容器也在文档内，它只保证组件的 DOM 树在文档内。<br>这个钩子，通常用于执行需要访问组件渲染的 DOM 的effect副作用，或者用于将与 DOM 相关的代码，限制在服务器渲染应用程序中的客户端。<br>在服务器端渲染期间不会调用此挂钩。</suspense></p><p>beforeUpdate -&gt; onBeforeUpdate DOM更新之前</p><p>updated -&gt; onUpdated DOM更新完毕<br>beforeDestroy -&gt; onBeforeUnmount 即将销毁<br>destroyed -&gt; onUnmounted 销毁完毕</p><p>errorCaptured -&gt; onErrorCaptured</p><h3 id="3、性能优化"><a href="#3、性能优化" class="headerlink" title="3、性能优化"></a>3、性能优化</h3><p> 双向响应原理由Object.defineProperty改为基于ES6的Proxy，使其颗粒度更⼤，速度更快，且消除了之前存在的警告、重写了 Vdom ，使其突破了 Vdom 的性能瓶颈、进⾏了模板编译的优化、进⾏了更加⾼效的组件初始化<br>Tree-Shaking 的⽀持<br>⽀持了tree-shaking（剪枝）：像修剪树叶⼀样把不需要的东西给修剪掉，使 Vue3 的体积更⼩。<br>需要的模块才会打⼊到包⾥，优化后的 Vue3.0 的打包体积只有原来的⼀半（13kb）。哪怕把所有的功能都引⼊进来也只有23kb，依然⽐Vue2.x 更⼩。</p><p>像keep-alive、transition甚⾄v-for等功能都可以按需引⼊。</p><p>Composition API<br>composition-api是⼀个 Vue3 中新增新增的功能，它的灵感来⾃于React Hooks，是⽐mixin更强⼤的存在。<br>composition-api可以提⾼代码逻辑的可复⽤性，从⽽实现与模板的⽆关性；同时使代码的可压缩性更强。另外，把Reactivity模块独⽴开来，意味着 Vue3.0 的响应式模块可以与其他框架相组合。composition-api把复杂组件的逻辑抽地更紧凑，⽽且可以将公共逻辑进⾏抽取。Fragments<br>不再限制template只有⼀个根节点。<br>render函数也可以返回数组了，有点像React.Fragments<br>Better TypeScript Support<br>更好的类型推导，使得 Vue3 把TypeScript⽀持得⾮常好<br>Custom Renderer API<br>实现⽤DOM的⽅式进⾏WebGL编程</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql高往低不兼容解决方案</title>
      <link href="/2022/07/08/mysql-gao-wang-di-bu-jian-rong-jie-jue-fang-an/"/>
      <url>/2022/07/08/mysql-gao-wang-di-bu-jian-rong-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<p>问题:</p><p>Unknown collation: ‘utf8mb4_0900_ai_ci‘的解决方法</p><p>分析:</p><p>出现这样的问题是原sql文件是mysql（8.0版本），高级往低级（5.6版本）导入时出现版本不兼容的情况。</p><p>解决</p><ol><li>把文件中的所有的utf8mb4_0900_ai_ci替换为utf8_general_ci</li><li>以及utf8mb4替换为utf8</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql图文安装教程</title>
      <link href="/2022/07/08/mysql-tu-wen-an-zhuang-jiao-cheng/"/>
      <url>/2022/07/08/mysql-tu-wen-an-zhuang-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>​       </p><p>​     </p><p>MySQL 8.0是一款广为人知的专业数据管理工具，该软件适用于所有的网站开发者和数据库开发者，它完全免费、开放源码，通过该软件你可以直接连接到MySQL数据库当中。MySQL为数据库管理、开发和维护提供了直观而强大的图形界面。MySQL基于         MySQL数据，由Oracle云提供支持，Oracle MySQL云服务提供了一个简单、自动化、集成和企业级的MySQL云服务，使企业能够提高业务灵活性和降低成本，是一款非常不错的数据库软件。</p><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p>下载地址:[mysql-installer-community-8.0.17.0]</p><pre class="line-numbers language-bash"><code class="language-bash">https://dev.mysql.com/downloads/file/?id<span class="token operator">=</span>488055<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p>1、勾选【I accept the license terms】，然后点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/1.png" alt></p><p>2、选择【Custom】，然后点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/2.png" alt></p><p>3、双击展开【MySQL Servers】</p><p><img src="https://lszai90.github.io/images/mysql/3.png" alt></p><p>4、继续双击展开【MySQL Servers】</p><p><img src="https://lszai90.github.io/images/mysql/4.png" alt></p><p>5、双击展开【MySQL Server 8.0】</p><p><img src="https://lszai90.github.io/images/mysql/5.png" alt></p><p>6、选中【MySQL Server 8.0.17-X64】，然后点击箭头按钮</p><p><img src="https://lszai90.github.io/images/mysql/6.png" alt></p><p>7、双击展开【MySQL Servers 8.0.17-X64】</p><p><img src="https://lszai90.github.io/images/mysql/7.png" alt></p><p>8、勾选【Documentation】，然后点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/8.png" alt></p><p>9、点击【Execute】</p><p><img src="https://lszai90.github.io/images/mysql/9.png" alt></p><p>10、等待进度走完</p><p><img src="https://lszai90.github.io/images/mysql/10.png" alt></p><p>11、点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/11.png" alt></p><p>12、.点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/12.png" alt></p><p>13、点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/13.png" alt></p><p>14、点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/14.png" alt></p><p>15、点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/15.png" alt></p><p>16、输入密码mysql，，然后点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/16.png" alt></p><p>17、点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/17.png" alt></p><p>18、点击【Execute】</p><p><img src="https://lszai90.github.io/images/mysql/18.png" alt></p><p>19、点击【Finish】</p><p><img src="https://lszai90.github.io/images/mysql/19.png" alt></p><p>20、点击【Next】</p><p><img src="https://lszai90.github.io/images/mysql/20.png" alt></p><p>21、点击【Finish】</p><p><img src="https://lszai90.github.io/images/mysql/21.png" alt></p><p>22、在桌面左下角开始菜单中找到【MySQL 8.0 Command Line Client】，鼠标拖拽到桌面上创建桌面快捷方式</p><p><img src="https://lszai90.github.io/images/mysql/22.jpeg" alt></p><p>23、鼠标右击【MySQL 8.0 Command Line Client】，选择【打开文件所在的位置】</p><p><img src="https://lszai90.github.io/images/mysql/23.jpeg" alt></p><p>24、点击如下图所示的空白处</p><p><img src="https://lszai90.github.io/images/mysql/24.png" alt></p><p>25、选中下图所示的文件夹路径，然后鼠标右击选择【复制】</p><p><img src="https://lszai90.github.io/images/mysql/25.png" alt></p><p>26、在桌面上找到【此电脑】，鼠标右击选择【属性】</p><p><img src="https://lszai90.github.io/images/mysql/26.jpeg" alt></p><p>27、点击【高级系统设置】</p><p><img src="https://lszai90.github.io/images/mysql/27.jpeg" alt></p><p>28、点击【环境变量】</p><p><img src="https://lszai90.github.io/images/mysql/28.png" alt></p><p>29、在系统变量中，找到并双击打开【Path】</p><p><img src="https://lszai90.github.io/images/mysql/29.png" alt></p><p>30、点击【新建】</p><p><img src="https://lszai90.github.io/images/mysql/30.png" alt></p><p>31、粘贴刚才复制的路径C:\Program Flies\MySQL\MySQL Server 8.0\bin。</p><p><img src="https://lszai90.github.io/images/mysql/31.png" alt></p><p>32、点击【确定】</p><p><img src="https://lszai90.github.io/images/mysql/32.png" alt></p><p>33、点击【确定】</p><p><img src="https://lszai90.github.io/images/mysql/33.png" alt></p><p>34、点击【确定】</p><p><img src="https://lszai90.github.io/images/mysql/34.png" alt></p><p>35、使用快捷键win+R键打开运行框、输入mysql -uroot -p，然后点击【确定】</p><p><img src="https://lszai90.github.io/images/mysql/35.jpeg" alt></p><p>36、输入密码mysql，按回车键、MySQL 8.0安装成功界面如下图所示</p><p><img src="https://lszai90.github.io/images/mysql/36.png" alt></p><p>37、如果想远程访问MySql</p><p>   update mysql.user set host=’%’ where user=’root’;</p><p>   想要立即生效需要执行刷新权限：</p><p>   flush privileges;</p><p>  如下图 就已经可以远程访问了。</p><p>  <img src="https://lszai90.github.io/images/mysql/37.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单HttpClient请求例子</title>
      <link href="/2022/07/07/jian-dan-httpclient-qing-qiu-li-zi/"/>
      <url>/2022/07/07/jian-dan-httpclient-qing-qiu-li-zi/</url>
      
        <content type="html"><![CDATA[<p>一个简单的HttpClient例子</p><p>代码如下:</p><pre class="line-numbers language-bash"><code class="language-bash">using <span class="token punctuation">(</span>var client <span class="token operator">=</span> new HttpClient<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">{</span>client.BaseAddress <span class="token operator">=</span> new Uri<span class="token punctuation">(</span><span class="token string">"http://localhost:1661/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var requestJson <span class="token operator">=</span> JsonConvert.SerializeObject<span class="token punctuation">(</span>new<span class="token punctuation">{</span>   <span class="token function">id</span> <span class="token operator">=</span> <span class="token string">"1"</span>,      name <span class="token operator">=</span> <span class="token string">"2"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//抛到httpContentHttpContent httpContent <span class="token operator">=</span> new StringContent<span class="token punctuation">(</span>requestJson<span class="token punctuation">)</span><span class="token punctuation">;</span> httpContent.Headers.ContentType <span class="token operator">=</span> new MediaTypeHeaderValue<span class="token punctuation">(</span><span class="token string">"application/json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> var result <span class="token operator">=</span> client.PostAsync<span class="token punctuation">(</span><span class="token string">"api/Product/AddProduct"</span>, httpContent<span class="token punctuation">)</span>.Result.Content.ReadAsStringAsync<span class="token punctuation">(</span><span class="token punctuation">)</span>.Result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Table作为参数</title>
      <link href="/2022/07/06/table-zuo-wei-can-shu/"/>
      <url>/2022/07/06/table-zuo-wei-can-shu/</url>
      
        <content type="html"><![CDATA[<p>在开发过程中难免会遇到直接把DT作为参数直接传给数据库中进行处理。</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><pre class="line-numbers language-bash"><code class="language-bash">--数据库； CREATE PROCEDURE dbo.sp_InsertSingleUser   <span class="token punctuation">(</span>     @User UserTable READONLY   <span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C-后台"><a href="#C-后台" class="headerlink" title="C# 后台"></a>C# 后台</h4><pre class="line-numbers language-bash"><code class="language-bash">   --后台传入的例子   public  DataSet fnInsertSingleUser<span class="token punctuation">(</span>DataTable v_dt<span class="token punctuation">)</span>  <span class="token punctuation">{</span>         try         <span class="token punctuation">{</span>             SqlConnection cn<span class="token operator">=</span>new SqlConnection<span class="token punctuation">(</span>CONN<span class="token punctuation">)</span><span class="token punctuation">;</span>             SqlCommand cmd<span class="token operator">=</span> cn.CreateCommand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             cmd.CommandType<span class="token operator">=</span> CommandType.StoredProcedure<span class="token punctuation">;</span>            cmd.CommandText<span class="token operator">=</span>@<span class="token string">"sp_InsertSingleUser"</span><span class="token punctuation">;</span>            SqlParameter p<span class="token operator">=</span> cmd.Parameters.AddWithValue<span class="token punctuation">(</span><span class="token string">"@User"</span>, v_dt<span class="token punctuation">)</span><span class="token punctuation">;</span>             DataSet ds <span class="token operator">=</span>new DataSet<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             SqlDataAdapter da<span class="token operator">=</span>new SqlDataAdapter<span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>            da.Fill<span class="token punctuation">(</span>ds<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         catch <span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            //写日志         <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Sql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pdfjs预览</title>
      <link href="/2022/07/05/pdfjs-yu-lan/"/>
      <url>/2022/07/05/pdfjs-yu-lan/</url>
      
        <content type="html"><![CDATA[<h4 id="PDFJS在线预览【-Net-Core】"><a href="#PDFJS在线预览【-Net-Core】" class="headerlink" title="PDFJS在线预览【.Net Core】"></a>PDFJS在线预览【.Net Core】</h4><p>主要使用Pdf.js 预览PDF文件、从后台返回base64 文件流</p><h5 id="第一步：下载pdf-js"><a href="#第一步：下载pdf-js" class="headerlink" title="第一步：下载pdf.js"></a>第一步：下载pdf.js</h5><pre class="line-numbers language-bash"><code class="language-bash">下载地址:http://mozilla.github.io/pdf.js/getting_started/<span class="token comment" spellcheck="true">#download</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="第二步-把解压的文件放到静态文件下-wwwroot"><a href="#第二步-把解压的文件放到静态文件下-wwwroot" class="headerlink" title="第二步:把解压的文件放到静态文件下[wwwroot]"></a>第二步:把解压的文件放到静态文件下[wwwroot]</h5><p><img src="https://lszai90.github.io/images/Pdfjs/www.png" alt></p><h5 id="第三步-后端返回流"><a href="#第三步-后端返回流" class="headerlink" title="第三步:后端返回流"></a>第三步:后端返回流</h5><p>注意: 我这里是传入系统的关键字、然后通过关键字[Etag]在数据库里面查询实际的路径、通过FileStream 读出文件流</p><pre class="line-numbers language-bash"><code class="language-bash">/// <span class="token operator">&lt;</span>summary<span class="token operator">></span>        /// 获取文件流        /// <span class="token operator">&lt;</span>/summary<span class="token operator">></span>        /// <span class="token operator">&lt;</span>param name<span class="token operator">=</span><span class="token string">"Params"</span><span class="token operator">></span><span class="token operator">&lt;</span>/param<span class="token operator">></span>        /// <span class="token operator">&lt;</span>returns<span class="token operator">></span><span class="token operator">&lt;</span>/returns<span class="token operator">></span>        <span class="token punctuation">[</span>HttpPost<span class="token punctuation">]</span>        public string getPdfStream<span class="token punctuation">(</span>string Params<span class="token punctuation">)</span>        <span class="token punctuation">{</span>  //定义的返回值            var returnstr <span class="token operator">=</span> new <span class="token punctuation">{</span> success <span class="token operator">=</span> <span class="token string">"false"</span>, message <span class="token operator">=</span> <span class="token string">""</span>, data <span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>//返回值             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>string.IsNullOrWhiteSpace<span class="token punctuation">(</span>Params<span class="token punctuation">))</span>            <span class="token punctuation">{</span>                //解密                var ParamsTwo <span class="token operator">=</span> DESEncrypt.Decrypt<span class="token punctuation">(</span>Params<span class="token punctuation">)</span><span class="token punctuation">;</span>                var Paramslength <span class="token operator">=</span> ParamsTwo.Split<span class="token punctuation">(</span><span class="token string">"|"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Paramslength.Length <span class="token operator">==</span> 3<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    //MD5解密                    string Etag <span class="token operator">=</span> Paramslength<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">;</span>                    long? tstamp <span class="token operator">=</span> long.Parse<span class="token punctuation">(</span>Paramslength<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    try                    <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>timestamphelper.differTimeStamp<span class="token punctuation">(</span>tstamp.Value<span class="token punctuation">))</span>                        <span class="token punctuation">{</span>                            var Model <span class="token operator">=</span> filesBLL.GetModel<span class="token punctuation">(</span>Etag<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>Model <span class="token operator">==</span> null<span class="token punctuation">)</span>                            <span class="token punctuation">{</span>                                returnstr <span class="token operator">=</span> new <span class="token punctuation">{</span> success <span class="token operator">=</span> <span class="token string">"false"</span>, message <span class="token operator">=</span> <span class="token string">"找不到对应的Etag的实体、请重新检查"</span>, data <span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">else</span>                            <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>Model.ExtName.ToUpper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">".PDF"</span><span class="token punctuation">)</span>                                <span class="token punctuation">{</span>                                    bool bo <span class="token operator">=</span> System.IO.File.Exists<span class="token punctuation">(</span>Model.FilePath<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bo<span class="token punctuation">)</span>                                    <span class="token punctuation">{</span>                                        returnstr <span class="token operator">=</span> new <span class="token punctuation">{</span> success <span class="token operator">=</span> <span class="token string">"false"</span>, message <span class="token operator">=</span> <span class="token string">"文件路径不存在"</span>, data <span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>                                    <span class="token punctuation">}</span>                                    <span class="token keyword">else</span>                                    <span class="token punctuation">{</span>                                        //即时释放                                        using <span class="token punctuation">(</span>FileStream readPdf <span class="token operator">=</span> new FileStream<span class="token punctuation">(</span>Model.FilePath, FileMode.Open<span class="token punctuation">))</span>                                        <span class="token punctuation">{</span>                                            long fileSize <span class="token operator">=</span> readPdf.Length<span class="token punctuation">;</span>                                            byte<span class="token punctuation">[</span><span class="token punctuation">]</span> bufferArray <span class="token operator">=</span> new byte<span class="token punctuation">[</span>fileSize<span class="token punctuation">]</span><span class="token punctuation">;</span>                                            readPdf.Read<span class="token punctuation">(</span>bufferArray, 0, <span class="token punctuation">(</span>int<span class="token punctuation">)</span>fileSize<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            readPdf.Close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                            string base64Str <span class="token operator">=</span> Convert.ToBase64String<span class="token punctuation">(</span>bufferArray<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            returnstr <span class="token operator">=</span> new <span class="token punctuation">{</span> success <span class="token operator">=</span> <span class="token string">"true"</span>, message <span class="token operator">=</span> <span class="token string">""</span>, data <span class="token operator">=</span> base64Str <span class="token punctuation">}</span><span class="token punctuation">;</span>                                        <span class="token punctuation">}</span>                                    <span class="token punctuation">}</span>                                <span class="token punctuation">}</span>                                <span class="token keyword">else</span>                                <span class="token punctuation">{</span>                                    returnstr <span class="token operator">=</span> new <span class="token punctuation">{</span> success <span class="token operator">=</span> <span class="token string">"false"</span>, message <span class="token operator">=</span> <span class="token string">"暂时不支持除了【.pdf】之外的格式预览"</span>, data <span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span>                        <span class="token punctuation">{</span>                            returnstr <span class="token operator">=</span> new <span class="token punctuation">{</span> success <span class="token operator">=</span> <span class="token string">"false"</span>, message <span class="token operator">=</span> <span class="token string">"链接失效"</span>, data <span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    catch <span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        returnstr <span class="token operator">=</span> new <span class="token punctuation">{</span> success <span class="token operator">=</span> <span class="token string">"false"</span>, message <span class="token operator">=</span> <span class="token string">"异常信息如下："</span> + ex.Message, data <span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    returnstr <span class="token operator">=</span> new <span class="token punctuation">{</span> success <span class="token operator">=</span> <span class="token string">"false"</span>, message <span class="token operator">=</span> <span class="token string">"对不起、密匙错误"</span>, data <span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>//返回值                 <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> JsonConvert.SerializeObject<span class="token punctuation">(</span>returnstr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="第四步-前端通过pdf-js进行预览"><a href="#第四步-前端通过pdf-js进行预览" class="headerlink" title="第四步:前端通过pdf.js进行预览"></a>第四步:前端通过pdf.js进行预览</h5><p>viewer.html</p><p>在【  <script src="viewer.js"></script>】 上面增加</p><pre class="line-numbers language-bash"><code class="language-bash">  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>        <span class="token keyword">function</span> getArgsFromHref<span class="token punctuation">(</span>sArgName<span class="token punctuation">)</span> <span class="token punctuation">{</span>            debugger<span class="token punctuation">;</span>            //   var sHref<span class="token operator">=</span>window.location.href<span class="token punctuation">;</span>            var sHref <span class="token operator">=</span> location.search<span class="token punctuation">;</span>            var args <span class="token operator">=</span> sHref.split<span class="token punctuation">(</span>sArgName + <span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var retval <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>            //args is null            <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">[</span>0<span class="token punctuation">]</span> <span class="token operator">==</span> sHref<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> retval<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            var retval <span class="token operator">=</span> args<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> retval<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        var url_file <span class="token operator">=</span> getArgsFromHref<span class="token punctuation">(</span><span class="token string">"url_file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        var DEFAULT_URL <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>//注意，删除的变量在这里重新定义        var PDFData <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        $.ajax<span class="token punctuation">(</span><span class="token punctuation">{</span>            type: <span class="token string">"POST"</span>,            async: false,            // mimeType: <span class="token string">'text/plain;charset=x-user-defined'</span>,            url: url_file,            success: <span class="token keyword">function</span> <span class="token punctuation">(</span>rJson<span class="token punctuation">)</span> <span class="token punctuation">{</span>                var rObj <span class="token operator">=</span> $.parseJSON<span class="token punctuation">(</span>rJson<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rObj.success <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    const code <span class="token operator">=</span> rObj.data.replace<span class="token punctuation">(</span>/<span class="token punctuation">[</span>\n\r<span class="token punctuation">]</span>/g, <span class="token string">''</span><span class="token punctuation">)</span>    // 检查base64字符串是否符合base64编码                    const raw <span class="token operator">=</span> window.atob<span class="token punctuation">(</span>code<span class="token punctuation">)</span>    // base64解码                    const rawLength <span class="token operator">=</span> raw.length    // 获取base64解码后的文件流字符串                    const uInt8Array <span class="token operator">=</span> new Uint8Array<span class="token punctuation">(</span>rawLength<span class="token punctuation">)</span>        // 初始化一个Uint8Array数组                    <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rawLength<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    // 转换Uint8Array类型                        uInt8Array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> raw.charCodeAt<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    // 将解码后的逐个字符转换成Unicode序号，放入Unit8Array数组                    <span class="token punctuation">}</span>                    DEFAULT_URL <span class="token operator">=</span> uInt8Array<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    alert<span class="token punctuation">(</span>rObj.message<span class="token punctuation">)</span><span class="token punctuation">;</span>                    window.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span>/script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>viewer.js </p><p>value：修改为【DEFAULT_URL】字段</p><pre class="line-numbers language-bash"><code class="language-bash">  defaultUrl: <span class="token punctuation">{</span>                    //value: <span class="token string">"compressed.tracemonkey-pldi-09.pdf"</span>,                    value: DEFAULT_URL,                    kind: OptionKind.VIEWER                <span class="token punctuation">}</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NetCore_解决请求数据大小限制</title>
      <link href="/2022/07/05/netcore-jie-jue-qing-qiu-shu-ju-da-xiao-xian-zhi/"/>
      <url>/2022/07/05/netcore-jie-jue-qing-qiu-shu-ju-da-xiao-xian-zhi/</url>
      
        <content type="html"><![CDATA[<h6 id="解决请求数据大小限制"><a href="#解决请求数据大小限制" class="headerlink" title="解决请求数据大小限制"></a>解决请求数据大小限制</h6><pre class="line-numbers language-bash"><code class="language-bash">利用Kestrel部署的应用配置接收数据的大小限制对于 Kestrel 托管的应用，默认的最大请求正文大小为 30,000,000 个字节，约为 28.6 MB。下面是处理数据大小限制的方式：注意：下面介绍的方式是基于Kestrel服务器上的配置，需要以.net core 的运行程序进行启动时才生效，以iis express 启动仍不生效。另外应用发布后使用nginx或者iis做反向代理服务器，还需要对反向代理服务器进行配置。1、 使用 MaxRequestBodySize属性自定义限制MaxRequestBodySize获取或设置任何请求正文的最大允许大小（以字节为单位）。设置为null时，最大请求正文大小是无限的。public static IHostBuilder CreateHostBuilder<span class="token punctuation">(</span>string<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>    Host.CreateDefaultBuilder<span class="token punctuation">(</span>args<span class="token punctuation">)</span>        .ConfigureWebHostDefaults<span class="token punctuation">(</span>webBuilder <span class="token operator">=</span><span class="token operator">></span>        <span class="token punctuation">{</span>            webBuilder.ConfigureKestrel<span class="token punctuation">((</span>context, options<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>            <span class="token punctuation">{</span>                options.Limits.MaxRequestBodySize <span class="token operator">=</span> 52428800<span class="token punctuation">;</span> // 限制50M，options.Limits.MaxRequestBodySize<span class="token operator">=</span>null表示不限制　　　　　　　<span class="token punctuation">}</span>　　　　　<span class="token punctuation">)</span> .UseStartup<span class="token operator">&lt;</span>Startup<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 　　　　<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>2、使用MultipartBodyLengthLimit 属性自定义限制MultipartBodyLengthLimit 设置每个正文的长度限制。 超出此限制时，会引发 InvalidDataException。 默认值为 134,217,728 <span class="token punctuation">(</span>128 MB<span class="token punctuation">)</span>。可以在 Startup.ConfigureServices 中设置限制public void ConfigureServices<span class="token punctuation">(</span>IServiceCollection services<span class="token punctuation">)</span><span class="token punctuation">{</span>    services.Configure<span class="token operator">&lt;</span>FormOptions<span class="token operator">></span><span class="token punctuation">(</span>options <span class="token operator">=</span><span class="token operator">></span>    <span class="token punctuation">{</span>        // Set the limit to 2G        options.MultipartBodyLengthLimit <span class="token operator">=</span> int.MaxValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>触发器语法</title>
      <link href="/2022/07/05/hong-fa-qi-yu-fa/"/>
      <url>/2022/07/05/hong-fa-qi-yu-fa/</url>
      
        <content type="html"><![CDATA[<h6 id="触发器语法"><a href="#触发器语法" class="headerlink" title="触发器语法"></a>触发器语法</h6><pre class="line-numbers language-bash"><code class="language-bash">ALTER trigger <span class="token punctuation">[</span>dbo<span class="token punctuation">]</span>.<span class="token punctuation">[</span>tri_XXXX<span class="token punctuation">]</span>on <span class="token punctuation">[</span>dbo<span class="token punctuation">]</span>.<span class="token punctuation">[</span>表<span class="token punctuation">]</span><span class="token keyword">for</span>  insert, delete, updateasbegin    <span class="token keyword">declare</span> @InsCount int    <span class="token keyword">declare</span> @DelCount int    <span class="token keyword">declare</span> @SRMCount int    <span class="token keyword">set</span> @InsCount <span class="token operator">=</span> 0     <span class="token keyword">set</span> @DelCount <span class="token operator">=</span> 0     <span class="token keyword">select</span> @InsCount <span class="token operator">=</span> count<span class="token punctuation">(</span>*<span class="token punctuation">)</span>    from   inserted    <span class="token keyword">select</span> @DelCount <span class="token operator">=</span> count<span class="token punctuation">(</span>*<span class="token punctuation">)</span>    from   deleted     <span class="token keyword">if</span> <span class="token punctuation">(</span>@InsCount <span class="token operator">></span> 0 and @DelCount <span class="token operator">=</span> 0<span class="token punctuation">)</span> ---插入    begin        print<span class="token punctuation">(</span><span class="token string">'Insert'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    end    <span class="token keyword">if</span> <span class="token punctuation">(</span>@InsCount <span class="token operator">></span> 0 and @DelCount <span class="token operator">></span> 0<span class="token punctuation">)</span> ---更新    begin      print<span class="token punctuation">(</span><span class="token string">'Update'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    end    <span class="token keyword">if</span> <span class="token punctuation">(</span>@InsCount <span class="token operator">=</span>0 and @DelCount <span class="token operator">></span> 0<span class="token punctuation">)</span> ---删除    begin        print<span class="token punctuation">(</span><span class="token string">'Del'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    endend <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Sql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql事务语法</title>
      <link href="/2022/07/04/sql-shi-wu-yu-fa/"/>
      <url>/2022/07/04/sql-shi-wu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h6 id="Sql-Server-事务语法"><a href="#Sql-Server-事务语法" class="headerlink" title="Sql Server 事务语法"></a>Sql Server 事务语法</h6><pre class="line-numbers language-bash"><code class="language-bash">--开始事物BEGIN TRAN           SET NOCOUNT ON BEGIN TRYCOMMIT TRANSET NOCOUNT OFFEND TRYBEGIN CATCH    SET @Msg<span class="token operator">=</span><span class="token string">'X'</span>    rollback TRANEND CATCH <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Sql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cursor</title>
      <link href="/2022/07/04/cursor/"/>
      <url>/2022/07/04/cursor/</url>
      
        <content type="html"><![CDATA[<h6 id="Sql-Server-游标语法"><a href="#Sql-Server-游标语法" class="headerlink" title="Sql Server 游标语法"></a>Sql Server 游标语法</h6><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">declare</span> @name nvarchar<span class="token punctuation">(</span>35<span class="token punctuation">)</span><span class="token keyword">declare</span> @number int<span class="token keyword">declare</span> my_cursor cursor <span class="token keyword">for</span>         --定义游标cursor1<span class="token keyword">select</span> TOP 5 <span class="token punctuation">[</span>name<span class="token punctuation">]</span>,<span class="token punctuation">[</span>number<span class="token punctuation">]</span> from <span class="token punctuation">[</span>spt_values<span class="token punctuation">]</span> --使用游标的对象<span class="token punctuation">(</span>跟据需要填入select文<span class="token punctuation">)</span><span class="token function">open</span> my_cursor                       --打开游标fetch next from my_cursor into @name,@number  --将游标向下移1行，获取的数据放入之前定义的变量@id,@name中while<span class="token punctuation">(</span>@@fetch_status<span class="token operator">=</span>0<span class="token punctuation">)</span>          --判断是否成功获取数据begin--update <span class="token punctuation">[</span>spt_values<span class="token punctuation">]</span> <span class="token keyword">set</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token operator">=</span>@name+<span class="token string">'1'</span>--where <span class="token punctuation">[</span>number<span class="token punctuation">]</span><span class="token operator">=</span>@number+1           --进行相应处理<span class="token punctuation">(</span>跟据需要填入SQL文<span class="token punctuation">)</span>print @nameprint @numberprint <span class="token string">'===='</span>fetch next from my_cursor into @name,@number  --将游标向下移1行endclose my_cursor                   --关闭游标deallocate my_cursor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Sql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA</title>
      <link href="/2022/06/19/rsa/"/>
      <url>/2022/06/19/rsa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
